<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>菜鸟小小浪</title>
   <link href="" rel="self" type="application/atom+xml"/>
   <link href="" rel="alternate" type="text/html" />
   <updated>2013-08-06T17:43:16+08:00</updated>
   <id></id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Grunt.js 在前端项目中的实战</title>
     <link href="http://beiyuu.com/blog/grunt-in-action"/>
     <updated>2013-07-17T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/grunt-in-action</id>
     <content type="html">&lt;h2&gt;Grunt是什么？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;是一个基于JavaScript的任务运行工具。&lt;/p&gt;

&lt;p&gt;为什么要使用Grunt，简而言之是为了“自动”，用工具自动完成压缩、编译、单元测试、拼写检查等重复性工作。&lt;/p&gt;

&lt;p&gt;Grunt的社区壮大非常快，现在支持的模块有：&lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt;、 &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;handlerbars&lt;/a&gt;、 &lt;a href=&quot;http://jade-lang.com/&quot;&gt;jade&lt;/a&gt;、 &lt;a href=&quot;http://www.jshint.com/&quot;&gt;JSHint&lt;/a&gt;、 &lt;a href=&quot;http://lesscss.org/&quot;&gt;Less&lt;/a&gt;、 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;、 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;Sass&lt;/a&gt;、 &lt;a href=&quot;http://learnboost.github.io/stylus/&quot;&gt;stylus&lt;/a&gt;等。&lt;/p&gt;

&lt;h2&gt;Grunt基本配置&lt;/h2&gt;

&lt;p&gt;Grunt及其插件都是用&lt;a href=&quot;https://npmjs.org/&quot;&gt;npm&lt;/a&gt;管理的，npm是&lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;的包管理程序，所以在使用Grunt之前，你需要先安装NodeJS。&lt;/p&gt;

&lt;h3&gt;安装CLI&lt;/h3&gt;

&lt;p&gt;首先需要在全局环境中安装Grunt command line interface (CLI)，在Mac等系统中需要sudo来执行下面的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这会将&lt;code&gt;grunt&lt;/code&gt;命令安装在系统path中，这样就可以从任何目录执行了。需要注意的是，安装了&lt;code&gt;grunt-cli&lt;/code&gt;并没有安装任务管理工具。&lt;code&gt;CLI&lt;/code&gt;的职责很简单，就是运行&lt;code&gt;Gruntfile&lt;/code&gt;中定义的&lt;code&gt;Grunt&lt;/code&gt;版本，这样你就可以在一台机器运行多个版本的Grunt。&lt;/p&gt;

&lt;p&gt;如果从0.3版本升级，需要先卸载旧版：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm uninstall -g grunt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;已存在Grunt的项目&lt;/h2&gt;

&lt;p&gt;对于已经使用了Grunt的项目，搭建本地环境是非常方便的，只需要切换到该项目目录，然后执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再使用&lt;code&gt;grunt&lt;/code&gt;命令运行Grunt即可。&lt;/p&gt;

&lt;h2&gt;新建Grunt项目&lt;/h2&gt;

&lt;p&gt;最基本的步骤就是给项目添加两个文件&lt;code&gt;package.json&lt;/code&gt;和&lt;code&gt;Gruntfile&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt;：在这个文件里你可以列出项目所需的Grunt插件，npm会自动下载。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grunfile&lt;/code&gt;：这个文件命名为&lt;code&gt;Gruntfile.js&lt;/code&gt;或者&lt;code&gt;Gruntfile.coffee&lt;/code&gt;，用来描述你所需要的grunt任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;package.json&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;文件需要放置在项目的根目录，和代码一起提交。运行&lt;code&gt;npm install&lt;/code&gt;命令，会安装&lt;code&gt;package.json&lt;/code&gt;中列出的依赖插件的正确版本。&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;package.json&lt;/code&gt;有以下几种办法：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;大部分&lt;code&gt;grunt-init&lt;/code&gt;模板，会创建项目相关的&lt;code&gt;package.json&lt;/code&gt;文件&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;npm init&lt;/code&gt;命令会创建基本的&lt;code&gt;package.json&lt;/code&gt;文件&lt;/li&gt;
    &lt;li&gt;也可以下面这个范本创建，更多用法可以看&lt;a href=&quot;https://npmjs.org/doc/json.html&quot; target=&quot;_blank&quot; class=&quot;external&quot;&gt;specification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;my-project-name&amp;quot;,
    &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,
    &amp;quot;devDependencies&amp;quot;: {
        &amp;quot;grunt&amp;quot;: &amp;quot;~0.4.1&amp;quot;,
        &amp;quot;grunt-contrib-jshint&amp;quot;: &amp;quot;~0.6.0&amp;quot;,
        &amp;quot;grunt-contrib-nodeunit&amp;quot;: &amp;quot;~0.2.0&amp;quot;,
        &amp;quot;grunt-contrib-uglify&amp;quot;: &amp;quot;~0.2.2&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;安装Grunt和插件&lt;/h3&gt;

&lt;p&gt;对于已存在&lt;code&gt;package.json&lt;/code&gt;文件的项目，最简单的安装方法就是&lt;code&gt;npm install &amp;lt;module&amp;gt; --save-dev&lt;/code&gt;，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install grunt --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令会安装最新版的&lt;code&gt;grunt&lt;/code&gt;，并且把对这个插件的依赖写入&lt;code&gt;package.json&lt;/code&gt;。很方便。&lt;/p&gt;

&lt;h2&gt;Gruntfile&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;package.json&lt;/code&gt;文件一样，&lt;code&gt;Gruntfile.js&lt;/code&gt;或者&lt;code&gt;Gruntfile.coffee&lt;/code&gt;需要放在根目录下和源码一起提交。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gruntfile&lt;/code&gt;由以下几个部分组成：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;wrapper&lt;/code&gt;函数&lt;/li&gt;
    &lt;li&gt;项目和任务配置&lt;/li&gt;
    &lt;li&gt;加载Grunt插件和任务&lt;/li&gt;
    &lt;li&gt;自定义任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;示例Gruntfile&lt;/h3&gt;

&lt;p&gt;在下面这个例子中，项目信息引自&lt;code&gt;package.json&lt;/code&gt;，grunt-contrib-uglify插件的&lt;code&gt;uglify&lt;/code&gt;任务用来压缩js文件，并且根据项目的metadata生成一条注释。当grunt运行时，uglify任务会默认执行。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    pkg: grunt.file.readJSON(&amp;#39;package.json&amp;#39;),
    uglify: {
      options: {
        banner: &amp;#39;/*! &amp;lt;%= pkg.name %&amp;gt; &amp;lt;%= grunt.template.today(&amp;quot;yyyy-mm-dd&amp;quot;) %&amp;gt; */\n&amp;#39;
      },
      build: {
        src: &amp;#39;src/&amp;lt;%= pkg.name %&amp;gt;.js&amp;#39;,
        dest: &amp;#39;build/&amp;lt;%= pkg.name %&amp;gt;.min.js&amp;#39;
      }
    }
  });

  // Load the plugin that provides the &amp;quot;uglify&amp;quot; task.
  grunt.loadNpmTasks(&amp;#39;grunt-contrib-uglify&amp;#39;);

  // Default task(s).
  grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;uglify&amp;#39;]);

};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是一个完整的&lt;code&gt;Gruntfile&lt;/code&gt;，我们仔细研究下。&lt;/p&gt;

&lt;h3&gt;wrapper函数&lt;/h3&gt;

&lt;p&gt;每个&lt;code&gt;Gruntfile&lt;/code&gt;（包括插件）使用这个默认的格式，你的所有的Grunt代码也必须写在这个函数中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module.export = function(grunt){
    //Do grunt-related things in here
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;项目和任务配置&lt;/h3&gt;

&lt;p&gt;大多Grunt的任务依赖于&lt;a href=&quot;http://gruntjs.com/grunt#grunt.initconfig&quot;&gt;grunt.initConfig&lt;/a&gt;方法中定义的配置。&lt;/p&gt;

&lt;p&gt;在这个例子中，Grunt通过&lt;code&gt;grunt.file.readJSON(&amp;#39;package.json&amp;#39;)&lt;/code&gt;引入了&lt;code&gt;package.json&lt;/code&gt;中定义的Grunt配置。因为&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;模板变量可以引用任何配置，所以像文件路径、文件列表这些内容应该存储在变量中，以减少重复。&lt;/p&gt;

&lt;p&gt;和其他任务一样，任务的配置需要和任务名字一样的变量，具体的参数可以查询各任务的文档。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Project configuration.
grunt.initConfig({
  pkg: grunt.file.readJSON(&amp;#39;package.json&amp;#39;),
  uglify: {
    options: {
      banner: &amp;#39;/*! &amp;lt;%= pkg.name %&amp;gt; &amp;lt;%= grunt.template.today(&amp;quot;yyyy-mm-dd&amp;quot;) %&amp;gt; */\n&amp;#39;
    },
    build: {
      src: &amp;#39;src/&amp;lt;%= pkg.name %&amp;gt;.js&amp;#39;,
      dest: &amp;#39;build/&amp;lt;%= pkg.name %&amp;gt;.min.js&amp;#39;
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;加载Grunt的插件和任务&lt;/h3&gt;

&lt;p&gt;很多常用的任务比如&lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-concat&quot;&gt;concatenation&lt;/a&gt;、 &lt;a href=&quot;http://github.com/gruntjs/grunt-contrib-uglify&quot;&gt;minification&lt;/a&gt;、 &lt;a href=&quot;https://github.com/gruntjs/grunt-contrib-jshint&quot;&gt;linting&lt;/a&gt;都有&lt;a href=&quot;https://github.com/gruntjs&quot;&gt;Grung插件&lt;/a&gt;。只要在&lt;code&gt;package.json&lt;/code&gt;中声明，然后通过&lt;code&gt;npm install&lt;/code&gt;安装，就可以在&lt;code&gt;Gruntfile&lt;/code&gt;中配置使用了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Load the plugin that provides the &amp;quot;uglify&amp;quot; task.
grunt.loadNpmTasks(&amp;#39;grunt-contrib-uglify&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;grunt --help&lt;/code&gt;可以查看所有可用的任务。&lt;/p&gt;

&lt;h3&gt;自定义任务&lt;/h3&gt;

&lt;p&gt;你可以配置让Grunt运行一个或多个默认任务。在例子中，运行&lt;code&gt;grunt&lt;/code&gt;不带任何参数就会执行&lt;code&gt;uglify&lt;/code&gt;任务。这和&lt;code&gt;grunt uglify&lt;/code&gt;或者&lt;code&gt;grunt default&lt;/code&gt;是一样的效果。数组的长度任意。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Default task(s).
grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;uglify&amp;#39;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你需要的任务并没有插件提供，那么也可以自定义，自定义的任务可以不写任务配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module.exports = function(grunt) {

  // A very basic default task.
  grunt.registerTask(&amp;#39;default&amp;#39;, &amp;#39;Log some stuff.&amp;#39;, function() {
    grunt.log.write(&amp;#39;Logging some stuff...&amp;#39;).ok();
  });

};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义的任务也不必一定写在&lt;code&gt;Gruntfile&lt;/code&gt;中，也可以定义在外部的&lt;code&gt;.js&lt;/code&gt;文件中，然后通过&lt;a href=&quot;http://gruntjs.com/grunt#grunt.loadtasks&quot;&gt;grunt.loadTasks&lt;/a&gt;来加载。&lt;/p&gt;

&lt;h2&gt;实战&lt;/h2&gt;

&lt;p&gt;grunt插件中有contrib前缀的是Grunt团队自行开发的插件，也是推荐使用的，下面挑选几个在前端项目中必用的插件，在实际例子中介绍一下使用方法。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-compass&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass&lt;/a&gt;是&lt;a href=&quot;http://sass-lang.com/&quot;&gt;SASS&lt;/a&gt;的一个框架，就像jQuery之于Javascript、Rails之于Ruby。具体的用法可以参考阮一峰的这两篇Blog:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/sass.html&quot;&gt;SASS用法指南&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/compass.html&quot;&gt;Compass用法指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，安装&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-compass&quot;&gt;grunt-contrib-compass&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install grunt-contrib-compass --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如前所述，&lt;code&gt;--save-dev&lt;/code&gt;可以在安装插件的过程中，将对这个插件的依赖自动写入&lt;code&gt;package.json&lt;/code&gt;文件中，方便。&lt;/p&gt;

&lt;p&gt;Compass并没有暴露所有的设置给Grunt，如果有别的需要，可以在config里面指定&lt;code&gt;config.rb&lt;/code&gt;给Compass编译使用。看一个配置的例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module.exports = function(grunt){
    grunt.initConfig({
      compass: {                  // compass任务
        dist: {                   // 一个子任务
          options: {              // 任务的设置
            sassDir: &amp;#39;sass&amp;#39;,
            cssDir: &amp;#39;css&amp;#39;,
            environment: &amp;#39;production&amp;#39;
          }
        },
        dev: {                    // 另一个子任务
          options: {
            sassDir: &amp;#39;sass&amp;#39;,
            cssDir: &amp;#39;style&amp;#39;
          }
        }
      }
    });

    grunt.loadNpmTasks(&amp;#39;grunt-contrib-compass&amp;#39;);

    grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;compass&amp;#39;]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要使用外部文件的配置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;grunt.initConfig({
  compass: {
    dist: {
      options: {
        config: &amp;#39;config/config.rb&amp;#39;
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;grunt-contrib-concat&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-concat&quot;&gt;grunt-contrib-concat&lt;/a&gt;是一个合并文件的插件，可以将多个css或js文件合并为一个，以节省链接数。同样的，安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install grunt-contrib-concat --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个插件有一下几个常用配置：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;seperator&lt;/code&gt;：被合并的文件会用这个参数来join，例如你在合并压缩后的js文件时，可以加个&lt;code&gt;;&lt;/code&gt;防止出错&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;banner&lt;/code&gt;：在合并后的文件头部加一些额外信息&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;footer&lt;/code&gt;：在合并后的文件尾部加一些额外信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再看一下用法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;grunt.initConfig({
  pkg: grunt.file.readJSON(&amp;#39;package.json&amp;#39;),
  concat: {
    options: {                                                      //配置
      stripBanners: true,
      banner: &amp;#39;/*! &amp;lt;%= pkg.name %&amp;gt; - v&amp;lt;%= pkg.version %&amp;gt; - &amp;#39; +      //添加自定义的banner
        &amp;#39;&amp;lt;%= grunt.template.today(&amp;quot;yyyy-mm-dd&amp;quot;) %&amp;gt; */&amp;#39;
    },
    dist: {                                                         //任务
        src: [&amp;#39;src/intro.js&amp;#39;, &amp;#39;src/project.js&amp;#39;, &amp;#39;src/outro.js&amp;#39;],    //源目录文件
        dest: &amp;#39;dist/built.js&amp;#39;                                       //合并后的文件
    },
    basic_and_extras: {                                             //另一个任务
        files: {                                                    //另一种更简便的写法
            &amp;#39;dist/basic.js&amp;#39;: [&amp;#39;src/main.js&amp;#39;],
            &amp;#39;dist/with_extras.js&amp;#39;: [&amp;#39;src/main.js&amp;#39;, &amp;#39;src/extras.js&amp;#39;]
        }
    }
  }
});

grunt.loadNpmTasks(&amp;#39;grunt-contrib-concat&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后在&lt;code&gt;default&lt;/code&gt;事件中添加&lt;code&gt;concat&lt;/code&gt;就会默认执行了。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-uglify&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-uglify&quot;&gt;grunt-contrib-uglify&lt;/a&gt;用来压缩js文件，用法与&lt;code&gt;concat&lt;/code&gt;类似，先安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install grunt-contrib-uglify --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后写入相应的配置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;grunt.initConfig({
  uglify: {
    options: {
      banner: &amp;#39;/*! This is uglify test - &amp;#39; +
        &amp;#39;&amp;lt;%= grunt.template.today(&amp;quot;yyyy-mm-dd&amp;quot;) %&amp;gt; */&amp;#39;
    },
    app_task: {
      files: {
        &amp;#39;dist/app.min.js&amp;#39;: [&amp;#39;js/app.js&amp;#39;, &amp;#39;js/render.js&amp;#39;]
      }
    }
  }
});

grunt.loadNpmTasks(&amp;#39;grunt-contrib-uglify&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;恩，经过如此处理，你的js代码已经丑陋到无法直视了。&lt;/p&gt;

&lt;h3&gt;grunt-contrib-watch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://npmjs.org/package/grunt-contrib-watch&quot;&gt;grunt-contrib-watch&lt;/a&gt;是开发必备插件，用来监控文件的修改，然后自动运行grunt任务，省去一遍遍手动执行Grunt命令，安装照旧：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;npm install grunt-contrib-watch --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用watch插件时，需要注意一点，被watch的文件，可以分开写，这样可以提高watch的性能，不用每次把没修改的文件也执行一遍任务，看看例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;grunt.initConfig({
  watch: {
    css: {
      files: [&amp;#39;public/scss/*.scss&amp;#39;],
      tasks: [&amp;#39;compass&amp;#39;],
      options: {
        // Start a live reload server on the default port 35729
        livereload: true,
      },
    },
    another: {
      files: [&amp;#39;lib/*.js&amp;#39;],
      tasks: [&amp;#39;anothertask&amp;#39;],
      options: {
        // Start another live reload server on port 1337
        livereload: 1337,
      },
    }
  }
});

grunt.loadNpmTasks(&amp;#39;grunt-contrib-watch&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行&lt;code&gt;grunt watch&lt;/code&gt;命令，修改文件，就会看到设定的任务执行了。&lt;/p&gt;

&lt;h2&gt;源码&lt;/h2&gt;

&lt;p&gt;Grunt的基本使用就是这些了，当然还有一些&lt;a href=&quot;http://gruntjs.com/project-scaffolding&quot;&gt;搭建脚手架&lt;/a&gt;等等的功能，等待你自己去学习使用吧，更多的&lt;a href=&quot;http://gruntjs.com/plugins/&quot;&gt;Grunt 插件&lt;/a&gt;也等待你去发现。&lt;/p&gt;

&lt;p&gt;贴出来源码，整体看一下：&lt;/p&gt;

&lt;h3&gt;package.json&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;Grunt-in-action&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;grunt&amp;quot;: &amp;quot;~0.4.1&amp;quot;,
    &amp;quot;grunt-contrib-compass&amp;quot;: &amp;quot;~0.3.0&amp;quot;,
    &amp;quot;grunt-contrib-watch&amp;quot;: &amp;quot;~0.4.4&amp;quot;,
    &amp;quot;grunt-contrib-concat&amp;quot;: &amp;quot;~0.3.0&amp;quot;,
    &amp;quot;grunt-contrib-uglify&amp;quot;: &amp;quot;~0.2.2&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Gruntfile.js&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module.exports = function(grunt){
    grunt.initConfig({
        compass: {                  // Task
            dist: {                   // Target
                options: {              // Target options
                    sassDir: &amp;#39;sass&amp;#39;,
                    cssDir: &amp;#39;css&amp;#39;,
                    environment: &amp;#39;production&amp;#39;
                }
            },
            dev: {                    // Another target
                options: {
                    sassDir: &amp;#39;sass&amp;#39;,
                    cssDir: &amp;#39;style&amp;#39;
                }
            }
        },

        concat: {
            options: {                                       //配置
                stripBanners:true,
                banner: &amp;#39;/*! This is the grunt test &amp;#39; +      //添加自定义的banner
                &amp;#39;&amp;lt;%= grunt.template.today(&amp;quot;yyyy-mm-dd&amp;quot;) %&amp;gt; */&amp;#39;
            },
            basic: {                                         //另一个任务
                files: {                                     //另一种更简便的写法
                    &amp;#39;dist/style.css&amp;#39;: [&amp;#39;style/screen.css&amp;#39;,&amp;#39;style/ie.css&amp;#39;,&amp;#39;style/print.css&amp;#39;]
                }
            }
        },

        uglify: {
            options: {
                banner: &amp;#39;/*! This is uglify test - &amp;#39; +
                &amp;#39;&amp;lt;%= grunt.template.today(&amp;quot;yyyy-mm-dd&amp;quot;) %&amp;gt; */&amp;#39;
            },
            app_task: {
                files: {
                    &amp;#39;dist/app.min.js&amp;#39;: [&amp;#39;js/app.js&amp;#39;, &amp;#39;js/render.js&amp;#39;]
                }
            }
        },

        watch: {
            css: {
                files: [&amp;#39;sass/*.scss&amp;#39;],
                tasks: [&amp;#39;compass&amp;#39;, &amp;#39;concat&amp;#39;]
            },
            another: {
                files: [&amp;#39;js/*.js&amp;#39;],
                tasks: [&amp;#39;uglify&amp;#39;]
            }
        }
    });

    grunt.loadNpmTasks(&amp;#39;grunt-contrib-compass&amp;#39;);
    grunt.loadNpmTasks(&amp;#39;grunt-contrib-concat&amp;#39;);
    grunt.loadNpmTasks(&amp;#39;grunt-contrib-uglify&amp;#39;);
    grunt.loadNpmTasks(&amp;#39;grunt-contrib-watch&amp;#39;);

    grunt.registerTask(&amp;#39;default&amp;#39;, [&amp;#39;compass&amp;#39;,&amp;#39;concat&amp;#39;, &amp;#39;uglify&amp;#39;]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
   </entry>
   
   <entry>
     <title>编写可读代码的艺术</title>
     <link href="http://beiyuu.com/blog/readable-code"/>
     <updated>2013-03-21T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/readable-code</id>
     <content type="html">&lt;p&gt;这是《The Art of Readable Code》的读书笔记，再加一点自己的认识。强烈推荐此书：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&quot;http://book.douban.com/subject/5442971/&quot; title=&quot;The Art Of Readable Code&quot;&gt;《The Art of Readable Code》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&quot;http://book.douban.com/subject/10797189/&quot; title=&quot;编写可读代码的艺术&quot;&gt;编写可读代码的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;代码为什么要易于理解&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Code should be written to minimize the time it would take for someone else to understand it.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;日常工作的事实是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写代码前的思考和看代码的时间远大于真正写的时间&lt;/li&gt;
&lt;li&gt;读代码是很平常的事情，不论是别人的，还是自己的，半年前写的可认为是别人的代码&lt;/li&gt;
&lt;li&gt;代码可读性高，很快就可以理解程序的逻辑，进入工作状态&lt;/li&gt;
&lt;li&gt;行数少的代码不一定就容易理解&lt;/li&gt;
&lt;li&gt;代码的可读性与程序的效率、架构、易于测试一点也不冲突&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整本书都围绕“如何让代码的可读性更高”这个目标来写。这也是好代码的重要标准之一。&lt;/p&gt;

&lt;h2&gt;如何命名&lt;/h2&gt;

&lt;h3&gt;变量名中应包含更多信息&lt;/h3&gt;

&lt;h4&gt;使用含义明确的词，比如用&lt;code&gt;download&lt;/code&gt;而不是&lt;code&gt;get&lt;/code&gt;，参考以下替换方案：&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt; send -&amp;gt; deliver, dispatch, announce, distribute, route
 find -&amp;gt; search, extract, locate, recover
start -&amp;gt; lanuch, create, begin, open
 make -&amp;gt; create,set up, build, generate, compose, add, new
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;避免通用的词&lt;/h4&gt;

&lt;p&gt;像&lt;code&gt;tmp&lt;/code&gt;和&lt;code&gt;retval&lt;/code&gt;这样词，除了说明是临时变量和返回值之外，没有任何意义。但是给他加一些有意义的词，就会很明确：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;tmp_file = tempfile.NamedTemporaryFile() 
...
SaveData(tmp_file, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不使用retval而使用变量真正代表的意义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;sum_squares += v[i]; // Where&amp;#39;s the &amp;quot;square&amp;quot; that we&amp;#39;re summing? Bug!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嵌套的for循环中,&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;也有同样让人困惑的时候：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;for (int i = 0; i &amp;lt; clubs.size(); i++)
    for (int j = 0; j &amp;lt; clubs[i].members.size(); j++)
        for (int k = 0; k &amp;lt; users.size(); k++) if (clubs[i].members[k] == users[j])
            cout &amp;lt;&amp;lt; &amp;quot;user[&amp;quot; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &amp;quot;] is in club[&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;]&amp;quot; &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换一种写法就会清晰很多：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt; if (clubs[ci].members[mi] == users[ui])  # OK. First letters match.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，当使用一些通用的词，要有充分的理由才可以。&lt;/p&gt;

&lt;h4&gt;使用具体的名字&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CanListenOnPort&lt;/code&gt;就比&lt;code&gt;ServerCanStart&lt;/code&gt;好，can start比较含糊，而listen on port确切的说明了这个方法将要做什么。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--run_locally&lt;/code&gt;就不如&lt;code&gt;--extra_logging&lt;/code&gt;来的明确。&lt;/p&gt;

&lt;h4&gt;增加重要的细节，比如变量的单位&lt;code&gt;_ms&lt;/code&gt;，对原始字符串加&lt;code&gt;_raw&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;如果一个变量很重要，那么在名字上多加一些额外的字就会更加易读，比如将&lt;code&gt;string id; // Example: &amp;quot;af84ef845cd8&amp;quot;&lt;/code&gt;换成&lt;code&gt;string hex_id;&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;             Start(int delay)  --&amp;gt;  delay → delay_secs
        CreateCache(int size)  --&amp;gt;  size → size_mb
ThrottleDownload(float limit)  --&amp;gt;  limit → max_kbps
          Rotate(float angle)  --&amp;gt;  angle → degrees_cw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;password  -&amp;gt;  plaintext_password
 comment  -&amp;gt;  unescaped_comment
    html  -&amp;gt;  html_utf8
    data  -&amp;gt;  data_urlenc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;对于作用域大的变量使用较长的名字&lt;/h4&gt;

&lt;p&gt;在比较小的作用域内，可以使用较短的变量名，在较大的作用域内使用的变量，最好用长一点的名字，编辑器的自动补全都可以很好的减少键盘输入。对于一些缩写前缀，尽量选择众所周知的(如str)，一个判断标准是，当新成员加入时，是否可以无需他人帮助而明白前缀代表什么。&lt;/p&gt;

&lt;h4&gt;合理使用&lt;code&gt;_&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;等符号，比如对私有变量加&lt;code&gt;_&lt;/code&gt;前缀。&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var x = new DatePicker(); // DatePicker() 是类的&amp;quot;构造&amp;quot;函数，大写开始
var y = pageHeight(); // pageHeight() 是一个普通函数

var $all_images = $(&amp;quot;img&amp;quot;); // $all_images 是jQuery对象
var height = 250; // height不是

//id和class的写法分开
&amp;lt;div id=&amp;quot;middle_column&amp;quot; class=&amp;quot;main-content&amp;quot;&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;命名不能有歧义&lt;/h3&gt;

&lt;p&gt;命名的时候可以先想一下，我要用的这个词是否有别的含义。举个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;results = Database.all_objects.filter(&amp;quot;year &amp;lt;= 2011&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在的结果到底是包含2011年之前的呢还是不包含呢？&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;代替&lt;code&gt;limit&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;CART_TOO_BIG_LIMIT = 10
    if shopping_cart.num_items() &amp;gt;= CART_TOO_BIG_LIMIT:
        Error(&amp;quot;Too many items in cart.&amp;quot;)

MAX_ITEMS_IN_CART = 10
    if shopping_cart.num_items() &amp;gt; MAX_ITEMS_IN_CART:
     Error(&amp;quot;Too many items in cart.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比上例中&lt;code&gt;CART_TOO_BIG_LIMIT&lt;/code&gt;和&lt;code&gt;MAX_ITEMS_IN_CART&lt;/code&gt;，想想哪个更好呢？&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;last&lt;/code&gt;来表示闭区间&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;print integer_range(start=2, stop=4)
# Does this print [2,3] or [2,3,4] (or something else)?

set.PrintKeys(first=&amp;quot;Bart&amp;quot;, last=&amp;quot;Maggie&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;last&lt;/code&gt;含义明确，适宜表示闭区间。&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;beigin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;表示前闭后开([2,9))区间&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;PrintEventsInRange(&amp;quot;OCT 16 12:00am&amp;quot;, &amp;quot;OCT 17 12:00am&amp;quot;)

PrintEventsInRange(&amp;quot;OCT 16 12:00am&amp;quot;, &amp;quot;OCT 16 11:59:59.9999pm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面一种写法就比下面的舒服多了。&lt;/p&gt;

&lt;h4&gt;Boolean型变量命名&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;bool read_password = true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个很危险的命名，到底是需要读取密码呢，还是密码已经被读取呢，不知道，所以这个变量可以使用&lt;code&gt;user_is_authenticated&lt;/code&gt;代替。通常，给Boolean型变量添加&lt;code&gt;is&lt;/code&gt;、&lt;code&gt;has&lt;/code&gt;、&lt;code&gt;can&lt;/code&gt;、&lt;code&gt;should&lt;/code&gt;可以让含义更清晰，比如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;             SpaceLeft()  --&amp;gt;  hasSpaceLeft()
bool disable_ssl = false  --&amp;gt;  bool use_ssl = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;符合预期&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;public class StatisticsCollector {
    public void addSample(double x) { ... }
    public double getMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;getMean&lt;/code&gt;方法遍历了所有的样本，返回总额，所以并不是普通意义上轻量的&lt;code&gt;get&lt;/code&gt;方法，所以应该取名&lt;code&gt;computeMean&lt;/code&gt;比较合适。&lt;/p&gt;

&lt;h2&gt;漂亮的格式&lt;/h2&gt;

&lt;p&gt;写出来漂亮的格式，充满美感，读起来自然也会舒服很多，对比下面两个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class StatsKeeper {
   public:
   // A class for keeping track of a series of doubles
      void Add(double d);  // and methods for quick statistics about them
     private:   int count;        /* how many so    far
   */ public:
           double Average();
   private:   double minimum;
   list&amp;lt;double&amp;gt;
     past_items
         ;double maximum;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;什么是充满美感的呢：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:
    void Add(double d);
    double Average();
  private:
    list&amp;lt;double&amp;gt; past_items;
    int count;  // how many so far
    double minimum;
    double maximum;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;考虑断行的连续性和简洁&lt;/h3&gt;

&lt;p&gt;这段代码需要断行，来满足不超过一行80个字符的要求，参数也需要注释说明：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;public class PerformanceTester {
    public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(
        500, /* Kbps */
        80, /* millisecs latency */
        200, /* jitter */
        1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(
        45000, /* Kbps */
        10, /* millisecs latency */
        0, /* jitter */
        0 /* packet loss % */);

    public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(
        100, /* Kbps */
        400, /* millisecs latency */
        250, /* jitter */
        5 /* packet loss % */);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑到代码的连贯性，先优化成这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;public class PerformanceTester {
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(
            500, /* Kbps */
            80, /* millisecs latency */ 200, /* jitter */
            1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
            45000, /* Kbps */
            10,    /* millisecs latency */
            0,     /* jitter */
            0      /* packet loss % */);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(
            100,   /* Kbps */
            400,   /* millisecs latency */
            250,   /* jitter */
            5      /* packet loss % */);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连贯性好一点，但还是太罗嗦，额外占用很多空间：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;public class PerformanceTester {
    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
    //                            [Kbps]   [ms]    [ms]    [percent]
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(500,    80,     200,     1);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(45000,  10,     0,       0);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(100,    400,    250,     5);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;用函数封装&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Turn a partial_name like &amp;quot;Doug Adams&amp;quot; into &amp;quot;Mr. Douglas Adams&amp;quot;.
// If not possible, &amp;#39;error&amp;#39; is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);

DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, &amp;quot;Doug Adams&amp;quot;, &amp;amp;error)
        == &amp;quot;Mr. Douglas Adams&amp;quot;);
assert(error == &amp;quot;&amp;quot;);
assert(ExpandFullName(database_connection, &amp;quot; Jake Brown &amp;quot;, &amp;amp;error)
        == &amp;quot;Mr. Jacob Brown III&amp;quot;);
assert(error == &amp;quot;&amp;quot;);
assert(ExpandFullName(database_connection, &amp;quot;No Such Guy&amp;quot;, &amp;amp;error) == &amp;quot;&amp;quot;);
assert(error == &amp;quot;no match found&amp;quot;);
assert(ExpandFullName(database_connection, &amp;quot;John&amp;quot;, &amp;amp;error) == &amp;quot;&amp;quot;);
assert(error == &amp;quot;more than one result&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段代码看起来很脏乱，很多重复性的东西，可以用函数封装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;CheckFullName(&amp;quot;Doug Adams&amp;quot;, &amp;quot;Mr. Douglas Adams&amp;quot;, &amp;quot;&amp;quot;);
CheckFullName(&amp;quot; Jake Brown &amp;quot;, &amp;quot;Mr. Jake Brown III&amp;quot;, &amp;quot;&amp;quot;);
CheckFullName(&amp;quot;No Such Guy&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;no match found&amp;quot;);
CheckFullName(&amp;quot;John&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;more than one result&amp;quot;);

void CheckFullName(string partial_name,
                   string expected_full_name,
                   string expected_error) {
    // database_connection is now a class member
    string error;
    string full_name = ExpandFullName(database_connection, partial_name, &amp;amp;error);
    assert(error == expected_error);
    assert(full_name == expected_full_name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;列对齐&lt;/h3&gt;

&lt;p&gt;列对齐可以让代码段看起来更舒适：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;CheckFullName(&amp;quot;Doug Adams&amp;quot;   , &amp;quot;Mr. Douglas Adams&amp;quot; , &amp;quot;&amp;quot;);
CheckFullName(&amp;quot; Jake  Brown &amp;quot;, &amp;quot;Mr. Jake Brown III&amp;quot;, &amp;quot;&amp;quot;);
CheckFullName(&amp;quot;No Such Guy&amp;quot;  , &amp;quot;&amp;quot;                  , &amp;quot;no match found&amp;quot;);
CheckFullName(&amp;quot;John&amp;quot;         , &amp;quot;&amp;quot;                  , &amp;quot;more than one result&amp;quot;);

commands[] = {
    ...
    { &amp;quot;timeout&amp;quot;      , NULL              , cmd_spec_timeout},
    { &amp;quot;timestamping&amp;quot; , &amp;amp;opt.timestamping , cmd_boolean},
    { &amp;quot;tries&amp;quot;        , &amp;amp;opt.ntry         , cmd_number_inf},
    { &amp;quot;useproxy&amp;quot;     , &amp;amp;opt.use_proxy    , cmd_boolean},
    { &amp;quot;useragent&amp;quot;    , NULL              , cmd_spec_useragent},
    ...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;代码用块区分&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class FrontendServer {
    public:
        FrontendServer();
        void ViewProfile(HttpRequest* request);
        void OpenDatabase(string location, string user);
        void SaveProfile(HttpRequest* request);
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void FindFriends(HttpRequest* request);
        void ReplyNotFound(HttpRequest* request, string error);
        void CloseDatabase(string location);
        ~FrontendServer();
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这一段虽然能看，不过还有优化空间：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class FrontendServer {
    public:
        FrontendServer();
        ~FrontendServer();
        // Handlers
        void ViewProfile(HttpRequest* request);
        void SaveProfile(HttpRequest* request);
        void FindFriends(HttpRequest* request);

        // Request/Reply Utilities
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void ReplyNotFound(HttpRequest* request, string error);

        // Database Helpers
        void OpenDatabase(string location, string user);
        void CloseDatabase(string location);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看一段代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Import the user&amp;#39;s email contacts, and match them to users in our system.
# Then display a list of those users that he/she isn&amp;#39;t already friends with.
def suggest_new_friends(user, email_password):
    friends = user.friends()
    friend_emails = set(f.email for f in friends)
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)
    display[&amp;#39;user&amp;#39;] = user
    display[&amp;#39;friends&amp;#39;] = friends
    display[&amp;#39;suggested_friends&amp;#39;] = suggested_friends
    return render(&amp;quot;suggested_friends.html&amp;quot;, display)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;全都混在一起，视觉压力相当大，按功能化块：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def suggest_new_friends(user, email_password):
    # Get the user&amp;#39;s friends&amp;#39; email addresses.
    friends = user.friends()
    friend_emails = set(f.email for f in friends)

    # Import all email addresses from this user&amp;#39;s email account.
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)

    # Find matching users that they aren&amp;#39;t already friends with.
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)

    # Display these lists on the page. display[&amp;#39;user&amp;#39;] = user
    display[&amp;#39;friends&amp;#39;] = friends
    display[&amp;#39;suggested_friends&amp;#39;] = suggested_friends

    return render(&amp;quot;suggested_friends.html&amp;quot;, display)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让代码看起来更舒服，需要在写的过程中多注意，培养一些好的习惯，尤其当团队合作的时候，代码风格比如大括号的位置并没有对错，但是不遵循团队规范那就是错的。&lt;/p&gt;

&lt;h2&gt;如何写注释&lt;/h2&gt;

&lt;p&gt;当你写代码的时候，你会思考很多，但是最终呈现给读者的就只剩代码本身了，额外的信息丢失了，所以注释的目的就是让读者了解更多的信息。&lt;/p&gt;

&lt;h3&gt;应该注释什么&lt;/h3&gt;

&lt;h4&gt;不应该注释什么&lt;/h4&gt;

&lt;p&gt;这样的注释毫无价值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// The class definition for Account
class Account {
    public:
        // Constructor
        Account();
        // Set the profit member to a new value
        void SetProfit(double profit);
        // Return the profit from this Account
        double GetProfit();
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;不要像下面这样为了注释而注释：&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Find a Node with the given &amp;#39;name&amp;#39; or return NULL.
// If depth &amp;lt;= 0, only &amp;#39;subtree&amp;#39; is inspected.
// If depth == N, only &amp;#39;subtree&amp;#39; and N levels below are inspected.
Node* FindNodeInSubtree(Node* subtree, string name, int depth);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;不要给烂取名注释&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Enforce limits on the Reply as stated in the Request,
// such as the number of items returned, or total byte size, etc. 
void CleanReply(Request request, Reply reply);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释的大部分都在解释clean是什么意思，那不如换个正确的名字：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Make sure &amp;#39;reply&amp;#39; meets the count/byte/etc. limits from the &amp;#39;request&amp;#39; 
void EnforceLimitsFromRequest(Request request, Reply reply);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;记录你的想法&lt;/h4&gt;

&lt;p&gt;我们讨论了不该注释什么，那么应该注释什么呢？注释应该记录你思考代码怎么写的结果，比如像下面这些：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Surprisingly, a binary tree was 40% faster than a hash table for this data.
// The cost of computing a hash was more than the left/right comparisons.

// This heuristic might miss a few words. That&amp;#39;s OK; solving this 100% is hard.

// This class is getting messy. Maybe we should create a &amp;#39;ResourceNode&amp;#39; subclass to
// help organize things.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以用来记录流程和常量：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// TODO: use a faster algorithm
// TODO(dustin): handle other image formats besides JPEG

NUM_THREADS = 8 # as long as it&amp;#39;s &amp;gt;= 2 * num_processors, that&amp;#39;s good enough.

// Impose a reasonable limit - no human can read that much anyway.
const int MAX_RSS_SUBSCRIPTIONS = 1000;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可用的词有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;TODO  : Stuff I haven&amp;#39;t gotten around to yet
FIXME : Known-broken code here
HACK  : Adimittedly inelegant solution to a problem
XXX   : Danger! Major problem here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;站在读者的角度去思考&lt;/h4&gt;

&lt;p&gt;当别人读你的代码时，让他们产生疑问的部分，就是你应该注释的地方。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;struct Recorder {
    vector&amp;lt;float&amp;gt; data;
    ...
    void Clear() {
        vector&amp;lt;float&amp;gt;().swap(data); // Huh? Why not just data.clear()? 
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很多C++的程序员啊看到这里，可能会想为什么不用&lt;code&gt;data.clear()&lt;/code&gt;来代替&lt;code&gt;vector.swap&lt;/code&gt;，所以那个地方应该加上注释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Force vector to relinquish its memory (look up &amp;quot;STL swap trick&amp;quot;)
vector&amp;lt;float&amp;gt;().swap(data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;说明可能陷阱&lt;/h4&gt;

&lt;p&gt;你在写代码的过程中，可能用到一些hack，或者有其他需要读代码的人知道的陷阱，这时候就应该注释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void SendEmail(string to, string subject, string body);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而实际上这个发送邮件的函数是调用别的服务，有超时设置，所以需要注释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Calls an external service to deliver email.  (Times out after 1 minute.)
void SendEmail(string to, string subject, string body);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;全景的注释&lt;/h4&gt;

&lt;p&gt;有时候为了更清楚说明，需要给整个文件加注释，让读者有个总体的概念：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// This file contains helper functions that provide a more convenient interface to our
// file system. It handles file permissions and other nitty-gritty details.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;总结性的注释&lt;/h4&gt;

&lt;p&gt;即使是在函数内部，也可以有类似文件注释那样的说明注释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Find all the items that customers purchased for themselves.
for customer_id in all_customers:
    for sale in all_sales[customer_id].sales:
        if sale.recipient == customer_id:
            ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者按照函数的步进，写一些注释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def GenerateUserReport():
    # Acquire a lock for this user
    ...
    # Read user&amp;#39;s info from the database
    ...
    # Write info to a file
    ...
    # Release the lock for this user
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很多人不愿意写注释，确实，要写好注释也不是一件简单的事情，也可以在文件专门的地方，留个写注释的区域，可以写下你任何想说的东西。&lt;/p&gt;

&lt;h3&gt;注释应简明准确&lt;/h3&gt;

&lt;p&gt;前一个小节讨论了注释应该写什么，这一节来讨论应该怎么写，因为注释很重要，所以要写的精确，注释也占据屏幕空间，所以要简洁。&lt;/p&gt;

&lt;h4&gt;精简注释&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// The int is the CategoryType.
// The first float in the inner pair is the &amp;#39;score&amp;#39;,
// the second is the &amp;#39;weight&amp;#39;.
typedef hash_map&amp;lt;int, pair&amp;lt;float, float&amp;gt; &amp;gt; ScoreMap;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写太罗嗦了，尽量精简压缩成这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// CategoryType -&amp;gt; (score, weight)
typedef hash_map&amp;lt;int, pair&amp;lt;float, float&amp;gt; &amp;gt; ScoreMap;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;避免有歧义的代词&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Insert the data into the cache, but check if it&amp;#39;s too big first.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code&gt;it&amp;#39;s&lt;/code&gt;有歧义，不知道所指的是&lt;code&gt;data&lt;/code&gt;还是&lt;code&gt;cache&lt;/code&gt;，改成如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Insert the data into the cache, but check if the data is too big first.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有更好的解决办法，这里的&lt;code&gt;it&lt;/code&gt;就有明确所指：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// If the data is small enough, insert it into the cache.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;语句要精简准确&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Depending on whether we&amp;#39;ve already crawled this URL before, give it a different priority.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句话理解起来太费劲，改成如下就好理解很多：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Give higher priority to URLs we&amp;#39;ve never crawled before.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;精确描述函数的目的&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Return the number of lines in this file.
int CountLines(string filename) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的一个函数，用起来可能会一头雾水，因为他可以有很多歧义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; &amp;quot;&amp;quot; 一个空文件，是0行还是1行？&lt;/li&gt;
&lt;li&gt; &amp;quot;hello&amp;quot; 只有一行，那么返回值是0还是1？&lt;/li&gt;
&lt;li&gt; &amp;quot;hello\n&amp;quot; 这种情况返回1还是2？&lt;/li&gt;
&lt;li&gt; &amp;quot;hello\n world&amp;quot; 返回1还是2？&lt;/li&gt;
&lt;li&gt; &amp;quot;hello\n\r cruel\n world\r&amp;quot; 返回2、3、4哪一个呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以注释应该这样写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Count how many newline bytes (&amp;#39;\n&amp;#39;) are in the file.
int CountLines(string filename) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;用实例说明边界情况&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Rearrange &amp;#39;v&amp;#39; so that elements &amp;lt; pivot come before those &amp;gt;= pivot;
// Then return the largest &amp;#39;i&amp;#39; for which v[i] &amp;lt; pivot (or -1 if none are &amp;lt; pivot)
int Partition(vector&amp;lt;int&amp;gt;* v, int pivot);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个描述很精确，但是如果再加入一个例子，就更好了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// ...
// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
int Partition(vector&amp;lt;int&amp;gt;* v, int pivot);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;说明你的代码的真正目的&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;void DisplayProducts(list&amp;lt;Product&amp;gt; products) {
    products.sort(CompareProductByPrice);
    // Iterate through the list in reverse order
    for (list&amp;lt;Product&amp;gt;::reverse_iterator it = products.rbegin(); it != products.rend();
            ++it)
        DisplayPrice(it-&amp;gt;price);
    ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的注释说明了倒序排列，单还不够准确，应该改成这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Display each price, from highest to lowest
for (list&amp;lt;Product&amp;gt;::reverse_iterator it = products.rbegin(); ... )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;函数调用时的注释&lt;/h4&gt;

&lt;p&gt;看见这样的一个函数调用，肯定会一头雾水：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Connect(10, false);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果加上这样的注释，读起来就清楚多了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def Connect(timeout, use_encryption):  ...

# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;使用信息含量丰富的词&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// This class contains a number of members that store the same information as in the
// database, but are stored here for speed. When this class is read from later, those
// members are checked first to see if they exist, and if so are returned; otherwise the
// database is read from and that data stored in those fields for next time.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这一大段注释，解释的很清楚，如果换一个词来代替，也不会有什么疑惑：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// This class acts as a caching layer to the database.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;简化循环和逻辑&lt;/h2&gt;

&lt;h3&gt;流程控制要简单&lt;/h3&gt;

&lt;p&gt;让条件语句、循环以及其他控制流程的代码尽可能自然，让读者在阅读过程中不需要停顿思考或者在回头查找，是这一节的目的。&lt;/p&gt;

&lt;h4&gt;条件语句中参数的位置&lt;/h4&gt;

&lt;p&gt;对比下面两种条件的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (length &amp;gt;= 10)
while (bytes_received &amp;lt; bytes_expected)

if (10 &amp;lt;= length)
while (bytes_expected &amp;gt; bytes_received)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到底是应该按照大于小于的顺序来呢，还是有其他的准则？是的，应该按照参数的意义来&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运算符左边：通常是需要被检查的变量，也就是会经常变化的&lt;/li&gt;
&lt;li&gt;运算符右边：通常是被比对的样本，一定程度上的常量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这就解释了为什么&lt;code&gt;bytes_received &amp;lt; bytes_expected&lt;/code&gt;比反过来更好理解。&lt;/p&gt;

&lt;h4&gt;if/else的顺序&lt;/h4&gt;

&lt;p&gt;通常，&lt;code&gt;if/else&lt;/code&gt;的顺序你可以自由选择，下面这两种都可以：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (a == b) {
    // Case One ...
} else {
    // Case Two ...
}

if (a != b) {
    // Case Two ...
} else {
    // Case One ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或许对此你也没有仔细斟酌过，但在有些时候，一种顺序确实好过另一种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正向的逻辑在前，比如&lt;code&gt;if(debug)&lt;/code&gt;就比&lt;code&gt;if(!debug)&lt;/code&gt;好&lt;/li&gt;
&lt;li&gt;简单逻辑的在前，这样&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;else&lt;/code&gt;就可以在一个屏幕显示&lt;/li&gt;
&lt;li&gt;有趣、清晰的逻辑在前&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子来看：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (!url.HasQueryParameter(&amp;quot;expand_all&amp;quot;)) {
    response.Render(items);
    ...
} else {
    for (int i = 0; i &amp;lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到&lt;code&gt;if&lt;/code&gt;你首先想到的是&lt;code&gt;expand_all&lt;/code&gt;，就好像告诉你“不要想大象”，你会忍不住去想它，所以产生了一点点迷惑，最好写成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (url.HasQueryParameter(&amp;quot;expand_all&amp;quot;)) {
    for (int i = 0; i &amp;lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
} else {
    response.Render(items);
    ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;三目运算符(?:)&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;time_str += (hour &amp;gt;= 12) ? &amp;quot;pm&amp;quot; : &amp;quot;am&amp;quot;;

Avoiding the ternary operator, you might write:
    if (hour &amp;gt;= 12) {
        time_str += &amp;quot;pm&amp;quot;;
    } else {
        time_str += &amp;quot;am&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用三目运算符可以减少代码行数，上例就是一个很好的例证，但是我们的真正目的是减少读代码的时间，所以下面的情况并不适合用三目运算符：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;return exponent &amp;gt;= 0 ? mantissa * (1 &amp;lt;&amp;lt; exponent) : mantissa / (1 &amp;lt;&amp;lt; -exponent);

if (exponent &amp;gt;= 0) {
    return mantissa * (1 &amp;lt;&amp;lt; exponent);
} else {
    return mantissa / (1 &amp;lt;&amp;lt; -exponent);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以只在简单表达式的地方用。&lt;/p&gt;

&lt;h4&gt;避免使用do/while表达式&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;do {
    continue;
} while (false);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码会执行几遍呢，需要时间思考一下，&lt;code&gt;do/while&lt;/code&gt;完全可以用别的方法代替，所以应避免使用。&lt;/p&gt;

&lt;h4&gt;尽早return&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;public boolean Contains(String str, String substr) {
    if (str == null || substr == null) return false;
    if (substr.equals(&amp;quot;&amp;quot;)) return true;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数里面尽早的return，可以让逻辑更加清晰。&lt;/p&gt;

&lt;h4&gt;减少嵌套&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (user_result == SUCCESS) {
    if (permission_result != SUCCESS) {
        reply.WriteErrors(&amp;quot;error reading permissions&amp;quot;);
        reply.Done();
        return;
    }
    reply.WriteErrors(&amp;quot;&amp;quot;);
} else {
    reply.WriteErrors(user_result);
}
reply.Done();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一段代码，有一层的嵌套，但是看起来也会稍有迷惑，想想自己的代码，有没有类似的情况呢？可以换个思路去考虑这段代码，并且用尽早return的原则修改，看起来就舒服很多：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (user_result != SUCCESS) {
    reply.WriteErrors(user_result);
    reply.Done();
    return;
}
if (permission_result != SUCCESS) {
    reply.WriteErrors(permission_result);
    reply.Done();
    return;
}
reply.WriteErrors(&amp;quot;&amp;quot;);
reply.Done();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的，对于有嵌套的循环，可以采用同样的办法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;for (int i = 0; i &amp;lt; results.size(); i++) {
    if (results[i] != NULL) {
        non_null_count++;
        if (results[i]-&amp;gt;name != &amp;quot;&amp;quot;) {
            cout &amp;lt;&amp;lt; &amp;quot;Considering candidate...&amp;quot; &amp;lt;&amp;lt; endl;
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换一种写法，尽早return，在循环中就用continue：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;for (int i = 0; i &amp;lt; results.size(); i++) {
    if (results[i] == NULL) continue;
    non_null_count++;

    if (results[i]-&amp;gt;name == &amp;quot;&amp;quot;) continue;
    cout &amp;lt;&amp;lt; &amp;quot;Considering candidate...&amp;quot; &amp;lt;&amp;lt; endl;
    ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;拆分复杂表达式&lt;/h3&gt;

&lt;p&gt;很显然的，越复杂的表达式，读起来越费劲，所以应该把那些复杂而庞大的表达式，拆分成一个个易于理解的小式子。&lt;/p&gt;

&lt;h4&gt;用变量&lt;/h4&gt;

&lt;p&gt;将复杂表达式拆分最简单的办法，就是增加一个变量：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if line.split(&amp;#39;:&amp;#39;)[0].strip() == &amp;quot;root&amp;quot;:

//用变量替换
username = line.split(&amp;#39;:&amp;#39;)[0].strip() 
if username == &amp;quot;root&amp;quot;:
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者这个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (request.user.id == document.owner_id) {
    // user can edit this document...
}
...
if (request.user.id != document.owner_id) {
// document is read-only...
}

//用变量替换
final boolean user_owns_document = (request.user.id == document.owner_id);
if (user_owns_document) {
    // user can edit this document...
}
...
if (!user_owns_document) {
    // document is read-only...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;逻辑替换&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1) not (a or b or c)   &amp;lt;--&amp;gt; (not a) and (not b) and (not c) &lt;/li&gt;
&lt;li&gt;2) not (a and b and c) &amp;lt;--&amp;gt; (not a) or (not b) or (not c)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，就可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (!(file_exists &amp;amp;&amp;amp; !is_protected)) Error(&amp;quot;Sorry, could not read file.&amp;quot;);

//替换
if (!file_exists || is_protected) Error(&amp;quot;Sorry, could not read file.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;不要滥用逻辑表达式&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;assert((!(bucket = FindBucket(key))) || !bucket-&amp;gt;IsOccupied());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的代码完全可以用下面这个替换，虽然有两行，但是更易懂：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket-&amp;gt;IsOccupied());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像下面这样的表达式，最好也不要写，因为在有些语言中，x会被赋予第一个为&lt;code&gt;true&lt;/code&gt;的变量的值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;x = a || b || c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;拆解大表达式&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var update_highlight = function (message_num) {
    if ($(&amp;quot;#vote_value&amp;quot; + message_num).html() === &amp;quot;Up&amp;quot;) {
        $(&amp;quot;#thumbs_up&amp;quot; + message_num).addClass(&amp;quot;highlighted&amp;quot;);
        $(&amp;quot;#thumbs_down&amp;quot; + message_num).removeClass(&amp;quot;highlighted&amp;quot;);
    } else if ($(&amp;quot;#vote_value&amp;quot; + message_num).html() === &amp;quot;Down&amp;quot;) {
        $(&amp;quot;#thumbs_up&amp;quot; + message_num).removeClass(&amp;quot;highlighted&amp;quot;);
        $(&amp;quot;#thumbs_down&amp;quot; + message_num).addClass(&amp;quot;highlighted&amp;quot;);
    } else {
        $(&amp;quot;#thumbs_up&amp;quot; + message_num).removeClass(&amp;quot;highighted&amp;quot;);
        $(&amp;quot;#thumbs_down&amp;quot; + message_num).removeClass(&amp;quot;highlighted&amp;quot;);
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面有很多重复的语句，我们可以用变量还替换简化：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var update_highlight = function (message_num) {
    var thumbs_up = $(&amp;quot;#thumbs_up&amp;quot; + message_num);
    var thumbs_down = $(&amp;quot;#thumbs_down&amp;quot; + message_num);
    var vote_value = $(&amp;quot;#vote_value&amp;quot; + message_num).html();
    var hi = &amp;quot;highlighted&amp;quot;;

    if (vote_value === &amp;quot;Up&amp;quot;) {
        thumbs_up.addClass(hi);
        thumbs_down.removeClass(hi);
    } else if (vote_value === &amp;quot;Down&amp;quot;) {
        thumbs_up.removeClass(hi);
        thumbs_down.addClass(hi);
    } else {
        thumbs_up.removeClass(hi);
        thumbs_down.removeClass(hi);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;变量与可读性&lt;/h3&gt;

&lt;h4&gt;消除变量&lt;/h4&gt;

&lt;p&gt;前一节，讲到利用变量来拆解大表达式，这一节来讨论如何消除多余的变量。&lt;/p&gt;

&lt;h4&gt;没用的临时变量&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;now = datetime.datetime.now()
root_message.last_view_time = now
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code&gt;now&lt;/code&gt;可以去掉，因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并非用来拆分复杂的表达式&lt;/li&gt;
&lt;li&gt;也没有增加可读性，因为`datetime.datetime.now()`本就清晰&lt;/li&gt;
&lt;li&gt;只用了一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以完全可以写作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;root_message.last_view_time = datetime.datetime.now()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;消除条件控制变量&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;boolean done = false;
while (/* condition */ &amp;amp;&amp;amp; !done) {
    ...
    if (...) {
        done = true;
        continue; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code&gt;done&lt;/code&gt;可以用别的方式更好的完成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;while (/* condition */) {
    ...
    if (...) {
        break;
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子非常容易修改，如果是比较复杂的嵌套，&lt;code&gt;break&lt;/code&gt;可能并不够用，这时候就可以把代码封装到函数中。&lt;/p&gt;

&lt;h4&gt;减少变量的作用域&lt;/h4&gt;

&lt;p&gt;我们都听过要避免使用全局变量这样的忠告，是的，当变量的作用域越大，就越难追踪，所以要保持变量小的作用域。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class LargeClass {
    string str_;
    void Method1() {
        str_ = ...;
        Method2();
    }
    void Method2() {
        // Uses str_
    }
    // Lots of other methods that don&amp;#39;t use str_ 
    ... ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code&gt;str_&lt;/code&gt;的作用域有些大，完全可以换一种方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class LargeClass {
    void Method1() {
        string str = ...;
        Method2(str); 
    }
    void Method2(string str) {
        // Uses str
    }
    // Now other methods can&amp;#39;t see str.
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将&lt;code&gt;str&lt;/code&gt;通过变量函数参数传递，减小了作用域，也更易读。同样的道理也可以用在定义类的时候，将大类拆分成一个个小类。&lt;/p&gt;

&lt;h4&gt;不要使用嵌套的作用域&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# No use of example_value up to this point.
if request:
    for value in request.values:
    if value &amp;gt; 0:
        example_value = value 
        break

for logger in debug.loggers:
    logger.log(&amp;quot;Example:&amp;quot;, example_value)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子在运行时候会报&lt;code&gt;example_value is undefined&lt;/code&gt;的错，修改起来不算难：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;example_value = None
if request:
    for value in request.values:
        if value &amp;gt; 0: example_value = value 
        break

if example_value:
    for logger in debug.loggers:
    logger.log(&amp;quot;Example:&amp;quot;, example_value)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是参考前面的&lt;strong&gt;消除中间变量&lt;/strong&gt;准则，还有更好的办法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def LogExample(value):
    for logger in debug.loggers:
        logger.log(&amp;quot;Example:&amp;quot;, value)

    if request:
        for value in request.values:
            if value &amp;gt; 0:
                LogExample(value)  # deal with &amp;#39;value&amp;#39; immediately
                break
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;用到了再声明&lt;/h4&gt;

&lt;p&gt;在C语言中，要求将所有的变量事先声明，这样当用到变量较多时候，读者处理这些信息就会有难度，所以一开始没用到的变量，就暂缓声明：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def ViewFilteredReplies(original_id):
    filtered_replies = []
    root_message = Messages.objects.get(original_id) 
    all_replies = Messages.objects.select(root_id=original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    for reply in all_replies:
        if reply.spam_votes &amp;lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读者一次处理变量太多，可以暂缓声明：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def ViewFilteredReplies(original_id):
    root_message = Messages.objects.get(original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    all_replies = Messages.objects.select(root_id=original_id) 
    filtered_replies = []
    for reply in all_replies:
        if reply.spam_votes &amp;lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;变量最好只写一次&lt;/h4&gt;

&lt;p&gt;前面讨论了过多的变量会让读者迷惑，同一个变量，不停的被赋值也会让读者头晕，如果变量变化的次数少一些，代码可读性就更强。&lt;/p&gt;

&lt;h4&gt;一个例子&lt;/h4&gt;

&lt;p&gt;假设有一个页面，如下，需要给第一个空的&lt;code&gt;input&lt;/code&gt;赋值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input1&amp;quot; value=&amp;quot;Dustin&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input2&amp;quot; value=&amp;quot;Trevor&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input3&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input4&amp;quot; value=&amp;quot;Melissa&amp;quot;&amp;gt;
...
var setFirstEmptyInput = function (new_value) {
    var found = false;
    var i = 1;
    var elem = document.getElementById(&amp;#39;input&amp;#39; + i);
    while (elem !== null) {
        if (elem.value === &amp;#39;&amp;#39;) {
            found = true;
            break; 
        }
        i++;
        elem = document.getElementById(&amp;#39;input&amp;#39; + i);
    }
    if (found) elem.value = new_value;
    return elem;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码能工作，有三个变量，我们逐一去看如何优化，&lt;code&gt;found&lt;/code&gt;作为中间变量，完全可以消除：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var setFirstEmptyInput = function (new_value) {
    var i = 1;
    var elem = document.getElementById(&amp;#39;input&amp;#39; + i);
    while (elem !== null) {
        if (elem.value === &amp;#39;&amp;#39;) {
            elem.value = new_value;
            return elem;
        }
        i++;
        elem = document.getElementById(&amp;#39;input&amp;#39; + i);
    }
    return null;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看&lt;code&gt;elem&lt;/code&gt;变量，只用来做循环，调用了很多次，所以很难跟踪他的值，&lt;code&gt;i&lt;/code&gt;也可以用&lt;code&gt;for&lt;/code&gt;来修改：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var setFirstEmptyInput = function (new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById(&amp;#39;input&amp;#39; + i);
        if (elem === null)
            return null;  // Search Failed. No empty input found.
        if (elem.value === &amp;#39;&amp;#39;) {
            elem.value = new_value;
            return elem;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;重新组织你的代码&lt;/h2&gt;

&lt;h3&gt;分离不相关的子问题&lt;/h3&gt;

&lt;p&gt;工程师就是将大问题分解为一个个小问题，然后逐个解决，这样也易于保证程序的健壮性、可读性。如何分解子问题，下面给出一些准则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看看这个方法或代码，问问你自己“这段代码的最终目标是什么？”&lt;/li&gt;
&lt;li&gt;对于每一行代码，要问“它与目标直接相关，或者是不相关的子问题？”&lt;/li&gt;
&lt;li&gt;如果有足够多行的代码是处理与目标不直接相关的问题，那么抽离成子函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;来看一个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ajax_post({
    url: &amp;#39;http://example.com/submit&amp;#39;,
    data: data,
    on_success: function (response_data) {
        var str = &amp;quot;{\n&amp;quot;;
        for (var key in response_data) {
            str += &amp;quot;  &amp;quot; + key + &amp;quot; = &amp;quot; + response_data[key] + &amp;quot;\n&amp;quot;;
        }
        alert(str + &amp;quot;}&amp;quot;);
        // Continue handling &amp;#39;response_data&amp;#39; ...
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的目标是发送一个&lt;code&gt;ajax&lt;/code&gt;请求，所以其中字符串处理的部分就可以抽离出来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var format_pretty = function (obj) {
    var str = &amp;quot;{\n&amp;quot;;
    for (var key in obj) {
        str += &amp;quot;  &amp;quot; + key + &amp;quot; = &amp;quot; + obj[key] + &amp;quot;\n&amp;quot;;
    }
    return str + &amp;quot;}&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;意外收获&lt;/h4&gt;

&lt;p&gt;有很多理由将&lt;code&gt;format_pretty&lt;/code&gt;抽离出来，这些独立的函数可以很容易的添加feature，增强可靠性，处理边界情况，等等。所以这里，可以将&lt;code&gt;format_pretty&lt;/code&gt;增强，就会得到一个更强大的函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var format_pretty = function (obj, indent) {
    // Handle null, undefined, strings, and non-objects.
    if (obj === null) return &amp;quot;null&amp;quot;;
    if (obj === undefined) return &amp;quot;undefined&amp;quot;;
    if (typeof obj === &amp;quot;string&amp;quot;) return &amp;#39;&amp;quot;&amp;#39; + obj + &amp;#39;&amp;quot;&amp;#39;;
    if (typeof obj !== &amp;quot;object&amp;quot;) return String(obj);
    if (indent === undefined) indent = &amp;quot;&amp;quot;;

    // Handle (non-null) objects.

    var str = &amp;quot;{\n&amp;quot;;
    for (var key in obj) {
        str += indent + &amp;quot;  &amp;quot; + key + &amp;quot; = &amp;quot;;
        str += format_pretty(obj[key], indent + &amp;quot; &amp;quot;) + &amp;quot;\n&amp;quot;; }
    return str + indent + &amp;quot;}&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数输出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;{
    key1 = 1
    key2 = true
    key3 = undefined
    key4 = null
    key5 = {
        key5a = {
            key5a1 = &amp;quot;hello world&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多做这样的事情，就是积累代码的过程，这样的代码可以复用，也可以形成自己的代码库，或者分享给别人。&lt;/p&gt;

&lt;h4&gt;业务相关的函数&lt;/h4&gt;

&lt;p&gt;那些与目标不相关函数，抽离出来可以复用，与业务相关的也可以抽出来，保持代码的易读性，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;business = Business()
business.name = request.POST[&amp;quot;name&amp;quot;]

url_path_name = business.name.lower()
url_path_name = re.sub(r&amp;quot;[&amp;#39;\.]&amp;quot;, &amp;quot;&amp;quot;, url_path_name) 
url_path_name = re.sub(r&amp;quot;[^a-z0-9]+&amp;quot;, &amp;quot;-&amp;quot;, url_path_name) 
url_path_name = url_path_name.strip(&amp;quot;-&amp;quot;)
business.url = &amp;quot;/biz/&amp;quot; + url_path_name

business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抽离出来，就好看很多：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;CHARS_TO_REMOVE = re.compile(r&amp;quot;[&amp;#39;\.&amp;#39;]+&amp;quot;)
CHARS_TO_DASH = re.compile(r&amp;quot;[^a-z0-9]+&amp;quot;)

def make_url_friendly(text):
    text = text.lower()
    text = CHARS_TO_REMOVE.sub(&amp;#39;&amp;#39;, text) 
    text = CHARS_TO_DASH.sub(&amp;#39;-&amp;#39;, text) 
    return text.strip(&amp;quot;-&amp;quot;)

business = Business()
business.name = request.POST[&amp;quot;name&amp;quot;]
business.url = &amp;quot;/biz/&amp;quot; + make_url_friendly(business.name) 
business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;简化现有接口&lt;/h4&gt;

&lt;p&gt;我们来看一个读写cookie的函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var max_results;
var cookies = document.cookie.split(&amp;#39;;&amp;#39;);
for (var i = 0; i &amp;lt; cookies.length; i++) {
    var c = cookies[i];
    c = c.replace(/^[ ]+/, &amp;#39;&amp;#39;);  // remove leading spaces
    if (c.indexOf(&amp;quot;max_results=&amp;quot;) === 0)
        max_results = Number(c.substring(12, c.length));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码实在太丑了，理想的接口应该是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;set_cookie(name, value, days_to_expire);
delete_cookie(name);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于并不理想的接口，你永远可以用自己的函数做封装，让接口更好用。&lt;/p&gt;

&lt;h4&gt;按自己需要写接口&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ser_info = { &amp;quot;username&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;...&amp;quot; }
user_str = json.dumps(user_info)
cipher = Cipher(&amp;quot;aes_128_cbc&amp;quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)
encrypted_bytes = cipher.update(user_str)
encrypted_bytes += cipher.final() # flush out the current 128 bit block
url = &amp;quot;http://example.com/?user_info=&amp;quot; + base64.urlsafe_b64encode(encrypted_bytes)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然终极目的是拼接用户信息的字符，但是代码大部分做的事情是解析python的object，所以：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def url_safe_encrypt(obj):
    obj_str = json.dumps(obj)
    cipher = Cipher(&amp;quot;aes_128_cbc&amp;quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str)
    encrypted_bytes += cipher.final() # flush out the current 128 bit block
    return base64.urlsafe_b64encode(encrypted_bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在其他地方也可以调用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;user_info = { &amp;quot;username&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;...&amp;quot; }
url = &amp;quot;http://example.com/?user_info=&amp;quot; + url_safe_encrypt(user_info)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分离子函数是好习惯，但是也要适度，过度的分离成多个小函数，也会让查找变得困难。&lt;/p&gt;

&lt;h3&gt;单任务&lt;/h3&gt;

&lt;p&gt;代码应该是一次只完成一个任务&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var place = location_info[&amp;quot;LocalityName&amp;quot;];  // e.g. &amp;quot;Santa Monica&amp;quot;
if (!place) {
    place = location_info[&amp;quot;SubAdministrativeAreaName&amp;quot;];  // e.g. &amp;quot;Los Angeles&amp;quot;
}
if (!place) {
    place = location_info[&amp;quot;AdministrativeAreaName&amp;quot;];  // e.g. &amp;quot;California&amp;quot;
}
if (!place) {
    place = &amp;quot;Middle-of-Nowhere&amp;quot;;
}
if (location_info[&amp;quot;CountryName&amp;quot;]) {
    place += &amp;quot;, &amp;quot; + location_info[&amp;quot;CountryName&amp;quot;];  // e.g. &amp;quot;USA&amp;quot;
} else {
    place += &amp;quot;, Planet Earth&amp;quot;;
}

return place;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个用来拼地名的函数，有很多的条件判断，读起来非常吃力，有没有办法拆解任务呢？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var town    = location_info[&amp;quot;LocalityName&amp;quot;];               // e.g. &amp;quot;Santa Monica&amp;quot;
var city    = location_info[&amp;quot;SubAdministrativeAreaName&amp;quot;];  // e.g. &amp;quot;Los Angeles&amp;quot;
var state   = location_info[&amp;quot;AdministrativeAreaName&amp;quot;];     // e.g. &amp;quot;CA&amp;quot;
var country = location_info[&amp;quot;CountryName&amp;quot;];                // e.g. &amp;quot;USA&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先拆解第一个任务，将各变量分别保存，这样在后面使用中不需要去记忆那些繁长的key值了，第二个任务，解决地址拼接的后半部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// Start with the default, and keep overwriting with the most specific value. var second_half = &amp;quot;Planet Earth&amp;quot;;
if (country) {
    second_half = country; 
}
if (state &amp;amp;&amp;amp; country === &amp;quot;USA&amp;quot;) {
    second_half = state; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来解决前半部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var first_half = &amp;quot;Middle-of-Nowhere&amp;quot;;
if (state &amp;amp;&amp;amp; country !== &amp;quot;USA&amp;quot;) {
    first_half = state; 
}
if (city) {
    first_half = city;
}
if (town) {
    first_half = town; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大功告成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;return first_half + &amp;quot;, &amp;quot; + second_half;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果注意到有&lt;code&gt;USA&lt;/code&gt;这个变量的判断的话，也可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var first_half, second_half;
if (country === &amp;quot;USA&amp;quot;) {
    first_half = town || city || &amp;quot;Middle-of-Nowhere&amp;quot;;
    second_half = state || &amp;quot;USA&amp;quot;;
} else {
    first_half = town || city || state || &amp;quot;Middle-of-Nowhere&amp;quot;;
    second_half = country || &amp;quot;Planet Earth&amp;quot;;
}
return first_half + &amp;quot;, &amp;quot; + second_half;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;把想法转换成代码&lt;/h3&gt;

&lt;p&gt;要把一个复杂的东西解释给别人，一些细节很容易就让人产生迷惑，所以想象把你的代码用平实的语言解释给别人听，别人是否能懂，有一些准则可以帮助你让代码更清晰：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用最平实的语言描述代码的目的，就像给读者讲述一样&lt;/li&gt;
&lt;li&gt;注意描述中关键的字词&lt;/li&gt;
&lt;li&gt;让你的代码符合你的描述&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这段代码用来校验用户的权限：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$is_admin = is_admin_request();
if ($document) {
    if (!$is_admin &amp;amp;&amp;amp; ($document[&amp;#39;username&amp;#39;] != $_SESSION[&amp;#39;username&amp;#39;])) {
        return not_authorized();
    }
} else {
    if (!$is_admin) {
        return not_authorized();
    } 
}
// continue rendering the page ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一段代码不长，里面的逻辑嵌套倒是复杂，参考前面章节所述，嵌套太多非常影响阅读理解，将这个逻辑用语言描述就是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;有两种情况有权限：
1、你是管理员(admin)
2、你拥有这个文档
否则就没有权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据描述来写代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (is_admin_request()) {
    // authorized
} elseif ($document &amp;amp;&amp;amp; ($document[&amp;#39;username&amp;#39;] == $_SESSION[&amp;#39;username&amp;#39;])) {
    // authorized
} else {
    return not_authorized();
}
// continue rendering the page ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;写更少的代码&lt;/h3&gt;

&lt;p&gt;最易懂的代码就是没有代码！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉那些没意义的feature，也不要过度设计&lt;/li&gt;
&lt;li&gt;重新考虑需求，解决最简单的问题，也能完成整体的目标&lt;/li&gt;
&lt;li&gt;熟悉你常用的库，周期性研究他的API&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;最后&lt;/h2&gt;

&lt;p&gt;还有一些与测试相关的章节，留给你自己去研读吧，再次推荐此书：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&quot;http://book.douban.com/subject/5442971/&quot; title=&quot;The Art Of Readable Code&quot;&gt;《The Art of Readable Code》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&quot;http://book.douban.com/subject/10797189/&quot; title=&quot;编写可读代码的艺术&quot;&gt;编写可读代码的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>宗教基本知识</title>
     <link href="http://beiyuu.com/blog/religion-basic"/>
     <updated>2013-01-10T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/religion-basic</id>
     <content type="html">&lt;p&gt;我并不想探究宗教的起源和对社会的影响等课题，作为一个宗教方面的文盲，就想了解些最基本概念，让我可以听得懂笑话，看得懂纠葛。&lt;/p&gt;

&lt;p&gt;基督教、伊斯兰教与佛教并列三大宗教。但要先从亚伯拉罕说起。&lt;/p&gt;

&lt;h2&gt;亚伯拉罕诸教&lt;/h2&gt;

&lt;p&gt;亚伯拉罕诸教，又称亚伯拉罕宗教、亚伯拉罕一神诸教、沙漠一神诸教、闪族一神诸教、闪米特一神诸教、闪米特诸教等，指世界主要的三个有共同源头的一神教──基督教（包括天主教、基督新教和东正教）、伊斯兰教和犹太教。如此所称，皆因这三个宗教均给予圣经旧约中的亚伯拉罕（阿拉伯语译作易卜拉因）崇高的地位，且均发源于西亚沙漠地区，来源于闪米特人的原始宗教。广义的沙漠宗教或闪米特宗教还包括当地或其族群中曾经存在的其他多神宗教，尽管现在通常直接用来指这三种一神教。&lt;/p&gt;

&lt;h3&gt;不同之处&lt;/h3&gt;

&lt;p&gt;犹太教认为亚伯拉罕和摩西是先知，直接受命于唯一真神（名曰耶和华）。耶和华通过摩西，与以色列人订立约定《十诫》，只要以色列人遵守约定，只崇拜唯一真神耶和华，耶和华将保佑以色列人。信仰上，犹太教只承认《塔纳赫》，即希伯来圣经或称希伯来手稿。犹太教不接受圣子论，他们并不认为耶稣及穆罕默德是他们的弥赛亚（救世主），并继续等待弥赛亚的来临。&lt;/p&gt;

&lt;p&gt;基督教脱胎于公元以一世纪左右一个新兴犹太教派。该教派认为犹太人违背了耶和华和以色列人定的约（即旧约），所以派祂的儿子耶稣作为弥赛亚（救世主）以自己的生命为人类赎罪，不仅和以色列人而和全体人类订立“新约”。&lt;/p&gt;

&lt;p&gt;伊斯兰教（在中国早期又称回教）不接受圣子论，穆斯林认为基督宗教内的三位一体（圣父、圣子、圣灵）是错误的，他们只承认独一真主（名曰安拉）。他们认为安拉每隔一段时间选出一位先知，但只有使者才被赐予一部经卷，亚丹（阿当）、易卜拉欣（亚伯拉罕）等只是先知，而穆萨（摩西）、尔萨（耶稣）既是先知又是使者，穆罕默德是安拉选出的最后一位先知，所谓“封印使者”。&lt;/p&gt;

&lt;h2&gt;基督教&lt;/h2&gt;

&lt;p&gt;基督教主要有天主教（又称公教会）、东正教（又称正教会）、基督新教（华人俗称基督教）三大派别。&lt;/p&gt;

&lt;p&gt;基督教基本经典是基督教圣经，由《旧约圣经》和《新约圣经》两大部分构成，有四十余位执笔作者，前后写作时间跨越约1600年。&lt;/p&gt;

&lt;p&gt;1054年，基督教分裂为公教（在中国称天主教）和正教（在中国称东正教）。天主教以罗马教廷为中心，教导权主要于教宗与大公会议；东正教以君士坦丁堡为中心，教会最高权力属于东罗马帝国的皇帝。1096年-1291年，天主教以维护基督教为口号，夺回被穆斯林占领的圣城耶路撒冷，展开了8次宗教战争（十字军东征）。&lt;/p&gt;

&lt;h3&gt;教义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;独一神（或唯一天主／独一上帝）：宇宙间有一位独一的至高神，是昔在、今在、永在的全能者，称为耶和华／雅威／耶和威。（英文：“God”，在基督公教里中文常译作“天主”。在基督新教里中文常译作“神”或“上帝”；）&lt;/li&gt;
&lt;li&gt;三位一体：独一神有圣父、圣子、圣灵（又译为圣神）三个位格，圣父是万有之源，圣子是耶稣基督，圣神是神的灵。三者同质、同能、同永恒，圣父是神，圣子是神，圣灵是神，但只有一位神，而非三个神。阿塔拿修信经对三位一体进行了比较得到公认的解释，但这仍然是比较难理解的一个概念。圣经中没有“三位一体”这个词，所以这是基督教的基本教义中较受争议的一项，但也被许多相信三位一体的基督徒看作是最重要的一项教义。否认三位一体的理论当中有一位一体论（只有一个神，乃是父）、三位三体论（父子灵乃是三个神）、形态论等。由于源自犹太教思想的基督教，也同样坚持“一神”论，因此三位一体与非三位一体论的争论焦点往往是耶稣基督的地位问题。&lt;/li&gt;
&lt;li&gt;创造：神创造了天地万物，最后照自己圣洁良善的形象造人，乃是造男造女，名为亚当和夏娃。&lt;/li&gt;
&lt;li&gt;罪与死：基督教的“罪”原文的字面意思是“不中靶心”，“罪”指一切不符合神的圣洁良善的行为、思想。人的始祖亚当和夏娃犯罪，带来了死。从此，罪与死入了世界，世人生而有罪（罪性），必然会犯罪（罪行）。如果没有神的救赎，都要走上灭亡之路，不仅肉体要死亡，灵魂也要永远死亡。&lt;/li&gt;
&lt;li&gt;基督救赎：耶稣基督本为神的儿子，与神同在，他就是神。耶稣基督为了将世人从罪恶中拯救出来而降世为人，从三十岁开始传道，在十字架上被钉死，他的无罪之身成了赎罪的祭，赎了世人的罪。他三日后从死里复活，升到天上，与父同在，他让父差下圣灵住在信他的人心中，与他们同在。他还活着，他在继续地作工。他将要再来，审判一切的活人死人，彻底地消灭罪，成就新天新地。&lt;/li&gt;
&lt;li&gt;复活与永生：耶稣基督将要再来，所有的人都要复活，接受最后的审判。信耶稣基督的人罪得赦免，得到永生，与神和好。罪不得赦免的最后会因罪而下地狱，与神永远隔绝。（圣经对末世的启示不是很清楚，基督教的末世论在细节上可以很复杂，不同意见也比较多。）&lt;/li&gt;
&lt;li&gt;荣耀：全然归给神，使人真正的谦卑下来，做“荣神益人”连结人的枝子。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;天主教&lt;/h3&gt;

&lt;p&gt;天主教是基督宗教三大宗派之一，正式名称为公教或公教会。天主教产生于公元一世纪的基督宗教，最初系自犹太教中分离出来，随着耶路撒冷的被占领，教会的中心逐渐转向帝国的首都罗马，故称“罗马公教”。从公元一世纪到五世纪初，罗马皇帝一再企图消灭教会，但到最后反倒是整个帝国皈依了教会，宣布罗马公教为罗马帝国的国教。&lt;/p&gt;

&lt;p&gt;天主教的经典为《圣经》，又称《新旧约全书》。信奉天父圣子圣神三位一体的真神。天主教会采用圣统制，神职人员奉行独身，天主教《教会法典》是教会的基本律法，用于规范宗教生活的各个方面。&lt;/p&gt;

&lt;h4&gt;信经十二端&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;全能的天主父，天地万物的创造者：天主是圣父、圣子、圣神三位一体，圣父是第一位格，是宇宙万物的创造者和主宰，并对人赏善罚恶。&lt;/li&gt;
&lt;li&gt;父的唯一子、主耶稣基督：天主圣子、主耶稣基督是天主三位一体中的第二位格，是圣父的独生子，圣父降下祂来到世间，为拯救有罪的世人脱离罪恶，得到永生。&lt;/li&gt;
&lt;li&gt;耶稣因圣神由童贞玛利亚诞生：天主教尊玛利亚为童贞圣母。童贞女玛利亚受圣神感动而怀孕，当时她已许配给若瑟，尚未出嫁。若瑟本想悄悄把她休去，但天主的使者在他梦中显现，指明玛利亚之孕乃从圣神来，让他娶她为妻，并为她所生之子取名耶稣。若瑟依天主旨意而行。&lt;/li&gt;
&lt;li&gt;耶稣在比拉多执政时蒙难，被钉十字架，死而安葬：耶稣30岁在加里肋亚和犹太各地传教，并拣选了12个门徒。他遭到犹太教上层经师及贵族的嫉恨，后来被其门徒犹大出卖，遭罗马帝国驻犹太总督彼拉多钉死在十字架上。&lt;/li&gt;
&lt;li&gt;耶稣死而复活：耶稣死后第三天复活。耶稣复活表明他确是天主的儿子，战胜了死亡，是世人的救主。因此死对于信仰耶稣的人不再可怕。&lt;/li&gt;
&lt;li&gt;耶稣升天：耶稣复活后第四十天升天，坐在天主的右边，同天主同享尊荣、永福。天主教认为，凡信仰耶稣者，死后灵魂能升入天堂。&lt;/li&gt;
&lt;li&gt;末日审判：在世界终结前，耶稣将要对世人进行审判，凡信仰耶稣基督并行善者可升入天堂得享永福，不得救赎者坠入地狱承受永苦。&lt;/li&gt;
&lt;li&gt;圣神：圣神是天主圣三中的第三位格，与圣父圣子一起同为唯一的真天主。“神”一词译自希伯来文&quot;Ruah&quot;，其原意是气息、空气、风。耶稣正是利用风的可感觉形象，来向尼苛德摩讲述新而超越的那一位，他是天主的气息、天主之神。另一方面，“圣”和“神”都是天主三位所共有的天主属性。但圣经、礼仪和神学术语却把这两个词放在一起，指明圣神那无可言喻的位格，以免与“圣”和“神”两字的其他用途相混淆。圣神于耶稣升天后第十天降临，坚固耶稣宗徒们的信心。圣神如同教会的灵魂，指引教会前进。圣神也在教徒的心中，勉励他们成圣。&lt;/li&gt;
&lt;li&gt;圣而公教会诸圣相通功：诸圣相通功communion of Saints是指所有教会成员，包括在光荣中的，经过炼狱的，及在世的教会成员，在天主圣三的生命与幸福上互相依赖，互通援助。&lt;/li&gt;
&lt;li&gt;罪过的赦免：天主教认为人类有原罪，这是因为人类始祖亚当和厄娃在伊甸园中，受蛇（撒旦）引诱违背天主命令吃了禁果，此罪传至后人，成为人类一切罪恶和灾祸的根由。教会有赦罪的权柄，信仰耶稣基督，接受洗礼的可以赦罪。犯了罪后向神父告解表示忏悔的，神父可以赦罪。&lt;/li&gt;
&lt;li&gt;肉身的复活：在世界末日到来时，死过的人一起复活，根据各人所行的善恶在天主面前接受审判。&lt;/li&gt;
&lt;li&gt;永生：天主教认为，人的物质生命是暂时的，而灵魂则是永恒的。凡信耶稣者，圣神进入内心，获得拯救，死后灵魂可升入天堂，得到永生。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;节日&lt;/h4&gt;

&lt;p&gt;圣诞节、复活节、圣神降临节和圣母升天节是天主教四大瞻礼。按天主教的礼仪年，每年从将临期（圣诞节前四周）开始。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;圣诞节为每年的12月25日。救主的诞生是救赎的开始。天主教从12月24日夜间即开始庆祝活动，俗称“平安夜”。&lt;/li&gt;
&lt;li&gt;复活节为每年春分后第一次月圆后的第一个星期天。耶稣复活是基督信仰的核心，没有主的复活就没有救赎。复活节的庆典从周六晚上开始，俗称“望复活”，隆重的点燃复活蜡烛仪式、嘹亮的《逾越颂》赞歌、庄严地重新宣发信仰等，最后在弥撒圣祭中将复活盛典推向高潮。&lt;/li&gt;
&lt;li&gt;圣神降临节为复活节后第五十天。圣神降临节是天主教会建立的开始。当年，充满了圣神的门徒们从四散逃避，到“往普天下去，向受造物传播福音”，直到用生命为主作证。因此天主教纪念主派遣圣神降临教会，圣化遍布各个国家和民族的普世教会，也求圣神降临信徒心中，继续在世界上开展传播福音的工作。&lt;/li&gt;
&lt;li&gt;圣母蒙召升天节为每年8月15日。天主教相信圣母玛利亚一生服从主的意愿，陪伴耶稣走完了十字架苦路，并把众人引向耶稣，“照他所吩咐的去做（加纳婚宴）”，为信徒做出了榜样，因此天主赏赐圣子的母亲灵魂肉身光荣升天。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;四大瞻礼中，复活节最隆重，圣诞节最喜庆热闹。&lt;/p&gt;

&lt;h3&gt;东正教&lt;/h3&gt;

&lt;p&gt;正教会（或称正统教会、东方正教，简称东正教）是基督教的主要宗派之一，是第二大宗派，信徒人数仅次于天主教，主要分布在希腊、土耳其、俄罗斯、白俄罗斯、乌克兰、罗马尼亚、保加利亚、塞尔维亚等东欧国家。&lt;/p&gt;

&lt;h4&gt;东西方教会的分裂&lt;/h4&gt;

&lt;p&gt;东正教会认为东正教是至圣、至公，从使徒传下来的正统教会。东正教认为基督教会是开放给世上所有的人，而不是仅属于特定的种族、阶级、或宗派。公元1054年，基督教发生了大分裂，基督教分裂成以东欧和西亚教会为中心的东正教、与西欧和南欧教会为中心的公教（即天主教）。东正教自称爲“正”（Orthodoxia，意爲“正统”），认为只有东正教会才保留了基督最原始的教导和传统。东正教相信，东正教信仰就是耶稣在世时传于圣徒的教导，这教导在正教会中代代相传，其实却不然。由于正教位于东方，故此又称爲“东正教”。&lt;/p&gt;

&lt;p&gt;公元11世纪发生在罗马和君士坦丁堡之间的大分裂导致西边的罗马天主教会和东边的教会完全分离。其原因是对教条和教宗的权力的分岐，文化和语言的不同亦加剧分裂（东边是希腊文化和希腊语，西边是拉丁文化和拉丁语）。&lt;/p&gt;

&lt;p&gt;普遍认为最后的分裂是公元1204年的第四次十字军东征攻下了君士坦丁堡的结果。西边的拉丁教会直接参与攻打拜占庭帝国和君士坦丁堡（正教宗主教所在地）的十字军东征。这次的战役导致的东西教会之间的敌意一直持续至今。2004年，罗马天主教会教宗若望·保禄二世对此事正式道歉；君士坦丁堡普世牧首巴多罗买一世（Bartholomew I）亦接受了道歉。&lt;/p&gt;

&lt;p&gt;公元1453年，拜占庭帝国被奥斯曼帝国征服，东正教会则保留下来。其时，东正教派教会分布的埃及受到信奉伊斯兰教的马木留克王朝的穆斯林的控制。但是正教派教会在俄国却非常强大；故时称第三罗马的莫斯科成了新的东正教会中心。&lt;/p&gt;

&lt;h4&gt;教会&lt;/h4&gt;

&lt;p&gt;与天主教以教廷为领导中心的形式不同，东正教由一些称爲“自主教会”或“自治教会”的地方教会组成。自主教会是东正教最高级别的独立教会，所有自主教会均不受其他教会的管辖。东正教最早的四个自主教会位于罗马帝国的四个重要的东方城市，即君士坦丁堡、亚历山大、耶路撒冷和安提阿。后来，俄罗斯正教会也取得了与它们同等的地位。比自主教会低一级的是东正教自治教会，它们由某一自主教会的领袖管辖。现在东正教共有15个自主教会。这些教会完全承认君士坦丁堡教会的君士坦丁堡牧首为普世大牧首地位可是在大公会议中土是大木手除了当主席以及整个正教会的发言人之外权利并不高过在长期他牧首，与其保持完全的共融。东正教的各个教会彼此在管理上独立，但皆有着共同的信仰并且在圣礼上完全共融。再者，正教会认为圣灵里到著整个正教会主导的大公会议的论店走向，亦在信到的人之间形成上帝在尘世的代表，所以不需要有一个教宗。&lt;/p&gt;

&lt;h4&gt;神学&lt;/h4&gt;

&lt;p&gt;一般来说，东正教派的神学和对于经卷的解释都是遵循基督教兴起初期所传下来的典范。他们所有的努力都是为了要继续和延续基督传给他最初使徒，以及使徒传给早期教会僧侣的神学和信仰。神学上的创新往往带来质疑；如果一个意见真的和最初的教会所教导的不同的话，那么这意见很可能被视为异端邪说。然而进一步的详细解说传统神学是可以被接受的。&lt;/p&gt;

&lt;p&gt;东方教会从不坚持要禁止图像敬拜，而西方新教教会最后都放弃图像敬拜。事实上，东西双方为图像敬拜都设立界线，并且订立了规条。然而当这个问题引致教会与政府发生磨擦时，东西方教会的关系就受到严重伤害。726年，皇帝利奥三世颁发反图像崇拜的命令，罗马主教因而指斥他，导致皇帝报复，撤消罗马对很多地方的管治权。罗马在失去了宝贵的土地的同时，另外发生了一连串的事情，影响到罗马的地位，矛头因而重新指向东方教会，指出其倾向国王兼教宗制度。皇帝干涉很多宗教的问题。但实际上所谓的国王兼教宗的制度是西方教会对正教的一种迷思，但正教会中，罗马皇帝的地位视为教会的守护者而非教宗。东正教没有教宗其永远的领袖是耶稣基督是圣灵，没有所谓尘世间的宗教领袖。&lt;/p&gt;

&lt;p&gt;另外 东正教的原罪观与救赎观已与西方教会不尽相同，对东正教而言，在人的堕落一事，真正的罪不是&amp;quot;亚当吃了那果子而那果子里装满了善恶嗔痴&amp;quot;而是&amp;quot;亚当自己选择远离上帝(一切生命存在之源)跑去吃那果子&amp;quot;又&amp;quot;避不见面甚至怪罪夏娃鱼吃果子一事&amp;quot;最终造成&amp;quot;罪的工价就是死&amp;quot;(罗6:23)的一个结果。按照东正教会的教导，罪是一种所有人承袭自地一个人的疾病，不是一种&amp;quot;犯罪纪录&amp;quot;。而耶稣基督的救赎不是为了赎、负责人的&amp;quot;闯祸犯罪纪录&amp;quot;而是要用医治的方式使罪远离人类。 并由死里复活亲身证明复活一事。&lt;/p&gt;

&lt;h3&gt;基督新教&lt;/h3&gt;

&lt;p&gt;新教，即基督教新教，是由16世纪宗教改革运动中脱离天主教会的教会和基督徒形成的一系列新宗派的统称，与“公教”、“正教”并列为基督教三大派别。汉语意为基督教的“新教会”或“新教派”；或根据德（Protestantismus）、英（Protestantism）、法（Protestantisme）等宗教改革起始地区的语言中对应单词的原意译为抗议宗、抗罗宗、反罗宗、反对教、誓反教、更正教、改新教等，词源均来自德语的“Protestanten”（抗议者）。汉语语境中所称的“基督教”大多即指新教，而非基督宗教所有派别。&lt;/p&gt;

&lt;p&gt;新教起源于西欧，原指1529年神圣罗马帝国举行的帝国议会中的少数反对派，该派诸侯对于会议通过支持天主教会压制宗教改革运动各派的决议提出了强烈的抗议，后即以其泛称宗教改革各新教派。&lt;/p&gt;

&lt;h4&gt;新教的形成&lt;/h4&gt;

&lt;p&gt;新教的抗议精神可以追溯至14世纪的一些宗教改革先行者，英国的威克里夫派以及罗拉德派、波希米亚的扬·胡斯派和意大利的萨伏那洛拉的信徒。16世纪20年代，马丁·路德在德国发起了宗教改革运动，迅速的席卷了整个德国，在日内瓦，加尔文的归正运动更进一步的加深了宗教改革的影响。&lt;/p&gt;

&lt;p&gt;到了16世纪中叶，主要宗派都以可以与旧教抗衡。因着教权与王权的权利争夺，新教在形成的过程中受到许多民族国家或世俗政权的支持与保护。在宗教战争后，根据随之而签订的合约，如1555年《奥格斯堡和约》与1648年《威斯特伐利亚和约》确立的教随国定原则，形成了新教在欧洲的布局，信义宗分布于德国以及北欧诸国；归正宗为德国、瑞士、荷兰以及苏格兰。&lt;/p&gt;

&lt;p&gt;16世纪末到17世纪，新教的主要宗派在教会的组织与崇拜仪式上已有基本雏形。对于教义的认定上经过长期的争论也逐渐成为体系。新教的神学家编写了大量的神学著作，但其内容多以繁琐的争辩以及考证为主，失去了改教初期那种富有抗议精神的活力。17世纪中叶，英格兰的清教徒运动要求以加尔文主义改革妥协保守的圣公宗教会，结果把新教运动又推进了一步，产生了脱离圣公宗的新教派，如英格兰的长老会、公理会、浸会、公谊会等等，而圣公宗本身则一直坚守大公信仰，时至今日仍是属于大公教会，却被普遍华人错误地归类为新教。随着移民美洲，新教也成为美洲宗派的大宗。&lt;/p&gt;

&lt;h4&gt;教导&lt;/h4&gt;

&lt;p&gt;因信称义
使徒保罗在《罗马书》第3章第23-25节说到“因为世人都犯了罪，亏缺了神的荣耀；如今却蒙神的恩典，因基督耶稣的救赎，就白白的称义。神设立耶稣作挽回祭，是凭著耶稣的血，借着人的信，要显明神的义；因为他用忍耐的心宽容人先时所犯的罪，好在今时显明他的义，使人知道他自己为义，也称信耶稣的人为义。”简单来说，信徒得以被称为义不是倚靠任何人为的善行或修练，而是源于神主动的恩典和赏赐，使世人因着圣灵奇妙的工作而向神悔改认罪并信靠主耶稣基督。使徒保罗在《罗马书》第5章第1-2节也说到“我们既因信称义，就借着我们的主耶稣基督得与神相和。我们又借着他，因信得进入现在所站的这恩典中，并且欢欢喜喜盼望神的荣耀。”&lt;/p&gt;

&lt;p&gt;信徒皆祭司
此教导建基于《彼得前书》第2章第9节“惟有你们是被拣选的族类，是有君尊的祭司、是圣洁的国度、是属神的子民，要叫你们宣扬那召你们出黑暗入奇妙光明者的美德。”故此，基督徒可以用耶稣基督的血，在主面前坦然无惧地事奉祂。此教导并非要信徒们轻看全时间被神呼召事奉主的神职人员，或高抬平信徒的地位；相对的是要鼓励所有平信徒，能在所有圣工上积极共同参与，同心合一来敬拜神。&lt;/p&gt;

&lt;h3&gt;三个派别的区别&lt;/h3&gt;

&lt;p&gt;A - 新教
B - 天主教
C - 代表东正教 &lt;/p&gt;

&lt;h4&gt;上帝论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A三位一体 圣灵发自父子 &lt;/li&gt;
&lt;li&gt;B三位一体 圣灵发自圣父和圣子 &lt;/li&gt;
&lt;li&gt;C三位一体 圣灵发自圣父 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;圣经论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A唯独圣经 &lt;/li&gt;
&lt;li&gt;B圣经＋反圣经的传统教皇无误论 &lt;/li&gt;
&lt;li&gt;C圣经＋反圣经的传统 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;基督论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A唯独基督 &lt;/li&gt;
&lt;li&gt;B圣徒和神甫是基督和人之间的中保，圣母马利亚是合作救主 &lt;/li&gt;
&lt;li&gt;C神甫是基督和人之间的中保 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;救赎论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A唯独本于恩典 唯独借着信心 唯独彰显荣耀 &lt;/li&gt;
&lt;li&gt;B凭借圣礼得救成圣；根据行为多次得救；数信徒死后封圣；炼狱说、无玷圣母说 &lt;/li&gt;
&lt;li&gt;C凭借圣像前的忏悔成圣，根据行为多次得救 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;教会论&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A众教会互为肢体，基督为元首 &lt;/li&gt;
&lt;li&gt;B梵帝冈为众教会之母教皇是基督在人间的代表 &lt;/li&gt;
&lt;li&gt;C众教会互为肢体，拜占廷主教为牧人之首（土耳其立国前） &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;圣餐说&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A 合质说 同在说 象征说 &lt;/li&gt;
&lt;li&gt;B化质说 &lt;/li&gt;
&lt;li&gt;C回避此问题，但领用有酵饼 &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;圣品制&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A无圣品人制度，有男女圣职，可结婚；但圣职不必要 &lt;/li&gt;
&lt;li&gt;B修道院制度和圣品人制度：终身修道者和圣品人不得结婚 &lt;/li&gt;
&lt;li&gt;C黑圣品人终生独身 白圣品人可以结婚 &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;洗礼&lt;/h3&gt;

&lt;p&gt;洗礼（或称浸礼、圣洗圣事），是一宗教仪式，现普遍指基督教的传统仪式。据《圣经》记载，施洗约翰曾为耶稣施洗，而这亦是耶稣吩咐的仪式。洗礼一词来自希腊文“Βάπτισμα”（Baptisma），原意是进入水中或沉入水中。部分基督教教派将洗礼列为圣事之一。&lt;/p&gt;

&lt;p&gt;洗礼通过把祝圣过的水倒在、撒向受洗者头上或把受浸者放进水中，然后扶起来施行。现天主教、东正教和大部分新教教派实施的婴儿洗礼，在2世纪时已有文献记录，教父指出是使徒传统。由于对洗礼有不同的理解，因而形成不同的宗派；不同的宗派内，在基督教历史上也发展出不同的教义。对于洗礼的讨论，主要提到：洗礼的效能，施洗的方法及婴孩、死人受洗等问题。&lt;/p&gt;

&lt;h3&gt;十诫&lt;/h3&gt;

&lt;p&gt;根据《圣经》记载，是上帝耶和华借由以色列的先知和首领摩西向以色列民族颁布的律法中的首要的十条规定，这大概是公元前1500年的事情。以十诫为代表的摩西律法是犹太人的生活和信仰的准则，也是最初的法律条文。在基督教中也有很重要的地位。&lt;/p&gt;

&lt;h4&gt;天主教以及路德宗&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;第一诫 钦崇一天主在万有之上。&lt;/li&gt;
&lt;li&gt;第二诫 毋呼天主圣名以发虚誓。&lt;/li&gt;
&lt;li&gt;第三诫 守瞻礼主日。&lt;/li&gt;
&lt;li&gt;第四诫 尊敬父母。&lt;/li&gt;
&lt;li&gt;第五诫 毋杀人。&lt;/li&gt;
&lt;li&gt;第六诫 毋行邪淫。&lt;/li&gt;
&lt;li&gt;第七诫 毋偷盗。&lt;/li&gt;
&lt;li&gt;第八诫 毋妄证。&lt;/li&gt;
&lt;li&gt;第九诫 毋愿他人妻。&lt;/li&gt;
&lt;li&gt;第十诫 毋贪他人财物。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;基督新教&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;第一条　 不可拜耶和华以外的上帝；&lt;/li&gt;
&lt;li&gt;第二条　 不可制造偶像与拜偶像；&lt;/li&gt;
&lt;li&gt;第三条　 不可妄称耶和华的名字；&lt;/li&gt;
&lt;li&gt;第四条　 当纪念安息日守为圣日；&lt;/li&gt;
&lt;li&gt;第五条　 应尊敬父母；&lt;/li&gt;
&lt;li&gt;第六条　 不可杀人；&lt;/li&gt;
&lt;li&gt;第七条　 不可奸淫；&lt;/li&gt;
&lt;li&gt;第八条　 不可偷盗；&lt;/li&gt;
&lt;li&gt;第九条　 不可作假见证；&lt;/li&gt;
&lt;li&gt;第十条　 不可贪心。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;伊斯兰教&lt;/h2&gt;

&lt;h3&gt;信条&lt;/h3&gt;

&lt;p&gt;伊斯兰教或回教，旧称清真教、天方教、大食法、大食教度、回回教，是以&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%8F%A4%E8%98%AD%E7%B6%93&quot;&gt;古兰经&lt;/a&gt;和&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E8%81%96%E8%A8%93&quot;&gt;圣训&lt;/a&gt;为教导的一神论宗教；古兰经被伊斯兰教信徒视为创造主安拉命天使给其使者逐字逐句的启示，而圣训为伊斯兰教先知穆罕默德的言行录（由同伴们转述收集）。伊斯兰这一名称来自闪语字根S-L-M，意为“顺从（真主）”；实际上穆斯林（伊斯兰教徒）的名字也来自这个字根，意为“顺从者”。穆斯林信仰独一且无与伦比的真主，名曰阿拉；人生的唯一目的是崇拜真主；真主派遣了多位先知给人类，包括易卜拉欣（亚伯拉罕）、穆萨（摩西）、尔撒（耶稣）等，但最终讯息是传达给最后的先知穆罕默德，并载于古兰经。&lt;/p&gt;

&lt;p&gt;伊斯兰教发源于七世纪早期的阿拉伯地区。古兰经提到，犹太教及基督教都是亚伯拉罕教义承袭下来的继后者，古兰经称犹太人和基督徒为“有经者”，以区别这些宗教与多神教。穆斯林认为部分的启示经文讨拉特（Tawrat，即摩西五经）及引支勒（Injil，即四福音书）在原文或释义上，甚至两者都被歪曲了。&lt;/p&gt;

&lt;p&gt;伊斯兰教的基本神学观念是认主学，即是伊斯兰教的一神论。真主在阿拉伯语里称作安拉，大部分学者都相信那是“al-ʾilāh”（神）的简化字，又有人将之追溯至阿拉姆语“Alāhā”。五功之一的认主学在清真言里有述，宣称除了真主以外再也没有其他的主宰，穆罕默德则是真主的使者。在传统伊斯兰神学里，真主是不可理解的。穆斯林不会将真主形像化，而只会作为一名顺从者崇拜、爱慕及敬畏祂。穆斯林只认为尔萨是一位先知，他们不认同基督教三位一体的教义。在伊斯兰神学里，耶稣只是一位凡人，而不是上帝的儿子。古兰经里描述真主为：“他是真主，是独一的主；真主是万物所仰赖的……除真主外，假如天地间还有许多神明，那么，天地必定破坏了。”&lt;/p&gt;

&lt;p&gt;穆罕默德是伊斯兰教的先知，他是创立伊斯兰教的宗教、政治及军事领袖。但穆斯林不视他为新宗教的创立者，而是亚当、亚伯拉罕、摩西、耶稣等一神论信仰的复兴者。在伊斯兰传统里，穆罕默德是最后一位及最伟大的先知，又是最接近完美的凡人，集所有美德于一身。在穆罕默德40岁以后人生最后的23年里，穆罕默德发布真主的啓示，这些啓示的内容被他的同伴记录下来，成为古兰经。&lt;/p&gt;

&lt;h3&gt;历史&lt;/h3&gt;

&lt;p&gt;根据伊斯兰教传统认为，从先知穆罕默德至四大哈里发时期属正统的伊斯兰历史，因除穆罕默德以外，不能根据任一穆斯林的行为代表伊斯兰，而穆罕默德之后的则只会视作为“穆斯林（行为）的历史”。&lt;/p&gt;

&lt;p&gt;由于西方文化在全球的普级性，华语世界普遍透过西方的观点来认识伊斯兰教历史，其内容多集中于西方世界与穆斯林世界在政治及军事上的冲突，例如穆斯林如何用武力扩张（阿拉伯帝国的崛起、十字军东征、君士坦丁堡之围、维也纳之围）或两者在宗教和文化上的差异等。&lt;/p&gt;

&lt;p&gt;伊斯兰教的历史进程对这个世界带来了深远的政治、经济、文化及军事影响。在穆罕默德首次诵读古兰经的一个世纪内，伊斯兰帝国的版图由西面的大西洋伸延至东面的中亚。这个新的政体很快便陷入内战，继承人相互攻伐，又要应付外来的威胁。虽然如此，伊斯兰教仍继续散播至非洲、印度次大陆及东南亚。在中世纪，伊斯兰文明是世上最先进的文明之一，但到近代，西方经济及军事上的增长使欧洲超越了伊斯兰世界。在十八至十九世纪，奥斯曼帝国、蒙兀儿帝国等穆斯林王朝被置于欧洲列强的阴影之下。二十世纪新一轮的宗教及政治运动及伊斯兰世界里新发现的财富导致了伊斯兰世界的再复兴及冲突。&lt;/p&gt;

&lt;p&gt;在中国、俄罗斯及加勒比地区都可找到庞大的穆斯林族群。最多穆斯林的国家是印度尼西亚，占全球穆斯林总数的15%。30%的穆斯林都位于南亚，20%的穆斯林在阿拉伯国家改信伊斯兰教的人及穆斯林移民几乎可在世界的每个角落都可找到。至2011年为止，全球约有13亿9300万穆斯林，人数上伊斯兰教是世界第二大宗教，被认为是世上增长得最快的宗教。&lt;/p&gt;

&lt;h3&gt;教规&lt;/h3&gt;

&lt;h4&gt;五功&lt;/h4&gt;

&lt;p&gt;伊斯兰教的五功是逊尼派的五个必要仪式。什叶派穆斯林奉行着他们的一套，但大体上与五功重叠。五功是指：
&lt;ul&gt;
&lt;li&gt;清真言：伊斯兰教的基本信经及教义：“我作证，万物非主，唯有真主；我作证，穆罕默德，是主使者。”这是伊斯兰教所有信念及仪式的基础。穆斯林须在礼拜时诵读清真言，一些非穆斯林要改信伊斯兰教也要吟诵清真言。&lt;/li&gt;
&lt;li&gt;萨拉赫：即礼拜，穆斯林每天必须礼拜五次，每次礼拜都面向麦加的克尔白进行。萨拉赫的意义是要专心致志予真主，被视为与真主的私人沟通，以表达感谢及崇拜之意。萨拉赫是必须履行的，但可视乎情况而弹性处理。&lt;/li&gt;
&lt;li&gt;天课：即施舍，这是施舍累积财富的行为，是所有财政状况许可的穆斯林的义务。他们有义务将积蓄的固定部分捐献出来，帮助穷人及用于传播伊斯兰教。天课被视为宗教义务，富人的财富是“真主恩惠的信托财产”，故富人有欠于穷人。古兰经及圣训都认为穆斯林应自愿捐献更多的财富。&lt;/li&gt;
&lt;li&gt;斋戒：穆斯林在赖买丹月的黎明至黄昏期间不吃不喝，并反省过错(除了孕妇、病人、旅行者或身处战场的士兵外)。斋戒是要追求靠近真主的感觉，穆斯林在赖买丹月须对真主怀着感恩及依靠之心，以弥补他们过去所犯的过失，关注穷人。对于一些会造成过度负担的人来说，斋戒不是必须的，也容许根据情况作弹性的处理，未能恪守斋戒的人须尽快弥补。&lt;/li&gt;
&lt;li&gt;朝觐：即伊斯兰历都尔黑哲月在麦加的朝觐。任何体格健全的穆斯林在一生里至少须到麦加朝觐一次。当朝觐者进入麦加十公里范围内时，朝觐者必须穿着受戒服装，由两件无缝的被单构成。朝觐仪式包括围绕克尔白步行七圈、触摸黑石、在萨法山与麦尔卧山之间来回奔走七次及象征性地在米纳（Mina）向魔鬼投石。朝觐者在他们的社区里备受尊重，伊斯兰教师认为朝觐是对真主虔诚的表达，不是获取社会地位的手法。&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;

&lt;h4&gt;礼仪和饮食&lt;/h4&gt;

&lt;p&gt;艾达卜（Adab）是指伊斯兰教的礼仪。这些礼仪包括以色兰（祝您平安）来问候他人、餐前诵太斯米（奉至仁至慈真主之名）、只用右手进食和吃喝。伊斯兰教的卫生习惯属于个人卫生及健康的范畴，如&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%89%B2%E7%A6%AE&quot;&gt;割礼&lt;/a&gt;、伊斯兰葬礼里对受到清洁及遮蔽后的尸体行殡礼并埋葬。&lt;/p&gt;

&lt;p&gt;穆斯林和犹太人一样在饮食上受到规限，猪肉、血、腐肉及酒等都被禁止进食。所有肉类都必须是由穆斯林、犹太人或基督徒以主之名屠宰的草食性动物，除了是亲自猎杀或捕杀享用。穆斯林可以食用的食物被称为哈拉勒。&lt;/p&gt;

&lt;h4&gt;殡葬&lt;/h4&gt;

&lt;p&gt;伊斯兰教认为应尽快举行简单的土葬，有“亡人奔土如奔金”之说，不等待奔丧。一般在死亡三天内举行。由死者亲人或其他穆斯林用水清洗尸体后以白布包裹。为死者行站礼祈祷。之后运往墓地土葬，尸体面朝圣地麦加天房（克尔白）方向，无棺材或陪葬品。整个葬礼过程中要求参与者节哀沉默（可哭泣但不可哭坟）。&lt;/p&gt;

&lt;h4&gt;家庭&lt;/h4&gt;

&lt;p&gt;伊斯兰社会的基本单位是家庭，伊斯兰教界定了家庭各个成员的义务和法定权利。父亲负责家庭的财政，有义务向他的家庭成员提供福利。财产继承的划分在古兰经里亦有说明，古兰经提到大部分遗产都会由直系亲属继承，一部分会用作支付债务及遗赠之用。妇女一般可继承的财产是拥有继承权男子的一半。伊斯兰教婚姻是民事合同的一种，是婚姻双方在两名见证人在场的要约和承诺。合同里规定新郎将聘礼（马尔，Mahr）送给新娘。&lt;/p&gt;

&lt;p&gt;穆斯林男子可以拥有多达四个妻子，只要他自己觉得能够平等地对待每一位妻子。相反，穆斯林女子只可以有一名丈夫。在许多穆斯林国家，伊斯兰教里的离婚又称为塔拉克（Talaq），丈夫须读出“离婚”来开始离婚的进程。学者对于圣典在传统的伊斯兰习俗如面纱、隔离的根据存在分歧。二十世纪伊始，穆斯林社会改革者反对这些诸如一夫多妻制的习俗，成效各异。同时，穆斯林妇女尝试以积极的生活方式和对外庄重的结合来顺应现代的潮流。一些伊斯兰组织如塔利班则力图继续实行适用于妇女的传统法律。&lt;/p&gt;

&lt;h2&gt;佛教&lt;/h2&gt;

&lt;h3&gt;基本&lt;/h3&gt;

&lt;p&gt;佛教是世界三大宗教之一，起源于古印度迦毗罗卫国的悉达多·乔达摩（佛号释迦牟尼）在大约西元前6世纪对于佛弟子所开示的教导，后发展为宗教。在世界上尤其是对于东亚和南亚地区具有广泛的影响。至2010年，全世界约有12亿佛教信众，人数仅次于基督教、伊斯兰教。&lt;/p&gt;

&lt;p&gt;佛，又称如来、应供、正遍知、明行足、善逝、世间解、无上士、调御丈夫、天人师、世尊，意思是“觉者”。佛教重视人类心灵和道德的进步和觉悟。按照佛教的观点，人和其他众生一样，沉沦于苦迫之中，并不断的轮转生死。惟有断灭贪、嗔、痴的人才能脱离轮回。悉达多·乔达摩就在35岁时成佛，并对众人宣扬他所发现的道理。佛教信徒修习佛教的目的即在于从悉达多所悟到的道理裏，看透生命和宇宙的真相，最终超越生死和苦、断尽一切烦恼，得到究竟解脱。&lt;/p&gt;

&lt;p&gt;佛教由古印度的悉达多·乔达摩35岁时创立，当时悉达多在毕钵罗树（佛教信徒尊称菩提树）下悟道，成立佛教。准备妥当之后，悉达多于是走遍恒河谷各地向人传教。五位贵族接受了悉达多的教训之后，成为比丘，也就是第一批僧侣或和尚。社会各阶层和各种身分的人都来听他演讲而成为他的弟子。在其后的几十年中游走四方，招收了许多弟子，佛教影响逐渐扩张。到他在80岁的高龄逝世（佛教称之为涅槃）时，他已举世闻名，被尊为释迦牟尼佛。&lt;/p&gt;

&lt;h3&gt;教义&lt;/h3&gt;

&lt;p&gt;佛教的基本教义从解脱众生苦难为出发点，以四谛十二缘起为核心。&lt;/p&gt;

&lt;h4&gt;轮回&lt;/h4&gt;

&lt;p&gt;佛教认为一切未解脱的有情众生都在天界、人道、阿修罗、畜生、饿鬼和地狱这六道里生死流转，无有止境。注意：轮回并不是创始于佛教的学说，佛教产生之前婆罗门教就有该学说，至今印度教各派仍然有该学说。&lt;/p&gt;

&lt;h4&gt;三法印&lt;/h4&gt;

&lt;p&gt;三法印即“诸行无常印、诸法无我印、涅槃寂静印”。 凡符合此三原则的，便是佛正法，有如世间印信，用为证明，故名法印。
&lt;ul&gt;
&lt;li&gt;诸行无常:是说一切世间法无时不在生住异灭中，过去有的，现在起了变异，现在有的，将来终归幻灭；&lt;/li&gt;
&lt;li&gt;诸法无我:是说在一切有为无为的诸法中，无有我的实体；所谓我的存在只是相对的生理和心理幻象。&lt;/li&gt;
&lt;li&gt;涅槃寂静:是说涅槃的境界，灭除一切生死的痛苦，无为安乐，故涅槃是寂静的。&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;

&lt;h4&gt;四圣谛&lt;/h4&gt;

&lt;p&gt;根据佛教，四圣谛学说是佛教教义的核心。
&lt;ul&gt;
&lt;li&gt;苦谛：佛教认为人生在世，谁也免不了生老病死。这些苦难不会因为人死亡结束，因为人死之后不是彻底消失，仍然会轮回不息，不论在地狱还是人间，苦总是存在的，只是程度不同罢了。 佛教还认为，世间的万物都是变化不定的，这叫做无常。对众生来说，因为于无常败坏法起贪著，则将造成身心的炽燃大苦，因此说无常故苦。&lt;/li&gt;
&lt;li&gt;集谛：集谛是讲苦产生的原因。 佛教认为世上没有无因之果，也没有无果之因。有情众生之所以会受苦，在于因无明而于六根触受起爱执，而导致后有生死的纯大苦聚集。&lt;/li&gt;
&lt;li&gt;灭谛：佛教认为只要是轮回，就无法避免会受苦。有情众生要想从苦中真正的、彻底的解脱出来，只有脱离轮回这一个办法。&lt;/li&gt;
&lt;li&gt;道谛：为了脱离轮回，必须进行修行。佛陀给出的方法主要为戒、定、慧三学。依八正道，便可以达到涅槃，永远从轮回中解脱出来，证得阿罗汉。&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;

&lt;h4&gt;十二因缘&lt;/h4&gt;

&lt;p&gt;佛教认为，世间万法都是依因缘而生，依因缘而存在。世上没有不依靠其他事物而独立存在的东西，任何事物都是因缘合和而成；没有什么东西能够不受其他事物的影响，也没有什么东西能够不影响任何其他事物；任何事物都有前因，也有后果，而这种因果关系构成了一个无始无终的链条。&lt;/p&gt;

&lt;p&gt;且依因缘而生之一切，也随着现象的生起，而损耗其赖之生起的因缘，是故世间一切皆无法恒常。&lt;/p&gt;

&lt;h2&gt;犹太教&lt;/h2&gt;

&lt;p&gt;犹太教崇拜单一的主神，是希伯来人内部的民族宗教。犹太教认为《塔木德》是仅次于《圣经》的经籍，传统观点认为，从犹太教中派生出了两个世界最大的宗教——基督宗教和伊斯兰教，但伊斯兰教则不承认该说法，穆斯林相信伊斯兰教的一神信仰内容才是最纯正的，而不是继承或抄袭犹太教和基督教。当亚历山大大帝征服希伯来人的犹太原居地后，希伯来人也易名为犹太人并散落到希腊帝国各处，公元前3世纪，希腊化的埃及托勒密王朝君主托勒密二世，召集70多位懂希腊语的犹太人，集中整理犹太教文献并译成希腊语，即目前基督教使用的希腊语圣经中的旧约全书部份，所谓七十士译本。再后来犹太国被罗马帝国彻底摧毁，犹太教位于耶路撒冷的圣殿被拆毁，只留下一段残破的西墙（俗称哭墙），犹太人散落到欧亚各地。&lt;/p&gt;

&lt;p&gt;历史上，犹太人曾面对多次毁灭性的灾难和逼害。犹太人由于两千多年一直分散在世界各地，语言、文字已经分化，只是靠着统一的宗教维系其单一的民族性。由于犹太教徒认为救世主尚未来临，不承认耶稣基督是救世主，这是一直受到基督教世界歧视和迫害的一个原因。但天主教教宗若望·保禄二世在近年，已承认曾对抗犹太教徒，造成了他们承受苦难的历史。&lt;/p&gt;

&lt;p&gt;他们向往自己民族的辉煌历史。19世纪，犹太复国主义（锡安主义）思潮兴起，各地犹太人以买地等手段陆续回到巴勒斯坦，建立以色列国家。由于在遵守方式和程度的差异，现今的犹太教主要有三大派系，分别是正统派、保守派及改革派。在三大派系之外，卡拉派也是犹太教的组成部分，可萨人信奉的就是卡拉派，目前卡拉派在以色列约有40000名信徒。&lt;/p&gt;

&lt;p&gt;一些宗教学者将犹太教、基督教和伊斯兰教通称为亚伯拉罕诸教，因为三者均奉旧约中的亚伯拉罕为他们的先知。&lt;/p&gt;

&lt;p&gt;犹太教认为《塔木德》是仅次于《圣经》的经籍，传统观点认为，从犹太教中派生出了两个世界最大的宗教——基督宗教和伊斯兰教，但伊斯兰教则不承认该说法，穆斯林相信伊斯兰教的一神信仰内容才是最纯正的，而不是继承或抄袭犹太教和基督教。&lt;/p&gt;

&lt;p&gt;犹太教只是一个民族性的宗教，信仰人口并不多，但在宗教界有很大的影响，犹太教和另外两个世界性宗教——伊斯兰教和基督宗教都有渊源。&lt;/p&gt;

&lt;p&gt;犹太人国家在公元79年被罗马帝国摧毁后，一部分犹太人流落到阿拉伯半岛，和阿拉伯人混居，他们的宗教与阿拉伯人宗教类似，两族都有一位共同祖先亚伯拉罕，阿拉伯人则称呼为（易卜拉因），是犹太教的教义都认同的。在古兰经中，也有很多和犹太教内容近似的地方。&lt;/p&gt;

&lt;p&gt;现在全世界信仰犹太教的人很少，只局限在犹太人内部，信众也少于同为特定民族信仰的锡克教、神道教。但每一部介绍宗教的书籍都少不了要提到犹太教，主要是因为其影响巨大。&lt;/p&gt;

&lt;h3&gt;教义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;相信耶和华是创天造地，唯一的真神。尊崇单一的、超越一切的上帝：&amp;quot;以色列阿，你要听。耶和华我们神是独一的主。&amp;quot;（申6:4），这与异教世界的泛神、多神宗教完全不同。&lt;/li&gt;
&lt;li&gt;严守十诫和律法。&lt;/li&gt;
&lt;li&gt;相信犹太人是天主的选民。&lt;/li&gt;
&lt;li&gt;期盼弥赛亚的降临，拯救整个犹太民族。反对偶像崇拜，在犹太人的圣殿中也没有任何上帝的有形形像。旧约就是上帝在犹太人历史中的行动的记录汇集，强调以色列国的命运，因此，个人的复活的教义并不常出现，但两约中间我们可以看到这个教义逐渐被强调。然而，国族主义和选民的意识决不会消失。犹太人期待弥赛亚为个人与社群带来奬赏, 也期盼他的到来会触动并影响个别的犹太人及整个族群和全人类。弥赛亚是希伯来文，意思是受膏者。这个观念首次出现在西元前931之后当所罗门王去世。之后犹太人经历国家分裂跟灭亡，所有的犹太人都盼望有一天能在所罗门王后裔的领导下恢复以往的荣耀，届时将是太平盛世，不再有饥饿、战争、疾病、痛苦。这也是犹太人无法接受耶稣是弥赛亚的主要原因，因为基督死后太平盛世并没有到来，犹太人依然过了几千年流离失所的日子。但是许多基督徒喜欢强调犹太人不愿意接受耶稣是弥赛亚，因为耶稣出生在贫苦像常人一样受苦、死亡，歧视犹太人以“身分卑微”来断定基督不是弥赛亚的说法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;习俗&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;会堂在犹太人宗教生活中相当重要。犹太人被掳没有圣殿的时候，就建立会堂。会堂的功用有：信徒聚会崇拜的地方、圣经学校、用于读经和讲解律法、祷告的地方、福利机构、平民学校、祭司和教师在此教导。&lt;/li&gt;
&lt;li&gt;圣殿在犹太人的国家生活和宗教生活占了最重要的地位，圣城耶路撒冷是国家的首都，敬拜神的圣殿是国家总部。即七十年为罗马提多将军夷为平地。&lt;/li&gt;
&lt;li&gt;犹太历节期共有七个：逾越节/无酵节、七七节、新年、赎罪日、住棚节、光明节、普珥节。前五个为摩西律法规定，后两个源自被掳回国以后。&lt;/li&gt;
&lt;li&gt;犹太公会罗马人允许犹太人掌理许多他们自己的宗教和本国的事务，因此存在很多的地方法庭。犹太最高的法庭就是大犹太议庭，甚至拥有警察权，大祭司率领超过七十位由法利赛人、撒都该人组成的法庭成员。这个议庭除了安息日和圣日之外，是每天开会的， 新约的记载是以“公会”、“祭司长和民间的长老”、“众祭司长和长老并文士”、“大祭司及官长”，或“众首领”来称呼，就是这个犹太的议会决定将耶稣处以死刑。&lt;/li&gt;
&lt;li&gt;散居的犹太人分为希伯来派、希腊派的犹太人。希伯来派：就是保存犹太教的宗教信仰，且使用希伯来或亚兰语言。希腊派：吸收希腊及罗马文化，除信仰上帝外，已完全不是犹太人，他们说希腊话，或居留地语言，随邻居习俗，分辨不出是犹太人。&lt;/li&gt;
&lt;li&gt;犹太的宗教教育犹太孩童所接受最初的宗教教育就是从父母学习希伯来历史及宗教，旧约摩西的律法和箴言都要求父母要负起这个责任。犹太男孩大约六岁时就进入地方性的会堂，以旧约为教科书来学习阅读和写作，由拉比来担任教职，也被教导包括圣经外的犹太传统和复杂的宗教仪式等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;反犹主义&lt;/h2&gt;

&lt;p&gt;反犹主义在各个不同历史时期有不同的动机和表现形式，但是其中也不乏共通性和延续性，例如将犹太人视为“谋杀救主基督的人”，“贪婪、阴险”的民族，“企图控制世界”的集团，需对世界一切政治和经济问题负责的“幕后黑手”等。&lt;/p&gt;

&lt;p&gt;反犹主义的思想和行为自产生至今导致灾难性后果。欧洲历史充斥着针对犹太人的暴力行为，犹太人受到歧视、侮辱、压迫和屠杀，例如十字军对犹太人的掠夺与屠杀，15世纪末期西班牙对犹太人的彻底驱逐，19世纪和20世纪沙皇俄国多次泛滥的反犹浪潮。而反犹主义的最高潮则公认是1933年至1945年之间纳粹大屠杀，造成约600万犹太人死亡。&lt;/p&gt;

&lt;p&gt;基督教认为耶稣是弥赛亚（“救世主”），是神，但是犹太人并不认为耶稣是犹太教信仰的弥赛亚，在《圣经·新约》中已经出现了对犹太人不认为耶稣是神、不赞同耶稣心意的描述。基督教将新的经典定名为《新约》，而把希伯来圣经称为“旧约”。在某些犹太人的记述中，耶稣是潘得拉强暴玛利亚所生，而基督教则认为耶稣是童贞女玛利亚所生；根据犹太人的记载，耶稣因犯罪受到惩罚被处死，而基督教则认为耶稣被犹太人迫害致死，这些都是部分极端基督徒仇恨犹太人的原因。&lt;/p&gt;

&lt;p&gt;虽然基督教反犹太历史悠久，但基督教的弥赛亚耶稣是犹太人。但基督徒通常不承认耶稣是“人”的存在，而是“神”三位一体的一种表现形式，更不承认耶稣是犹太人（而且基督徒一般确信是犹太人出卖并导致了耶稣的死亡）。&lt;/p&gt;

&lt;h2&gt;相关资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%9E%E4%BC%AF%E6%8B%89%E7%BD%95%E8%AB%B8%E6%95%99&quot;&gt;亚伯拉罕诸教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%9F%BA%E7%9D%A3%E5%AE%97%E6%95%99&quot;&gt;基督教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BC%8A%E6%96%AF%E8%98%AD%E6%95%99&quot;&gt;伊斯兰教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BD%9B%E6%95%99&quot;&gt;佛教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%9F%BA%E7%9D%A3%E6%95%99%E5%92%8C%E7%8A%B9%E5%A4%AA%E6%95%99&quot;&gt;基督教和犹太教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%8C%B6%E5%A4%AA%E6%95%99&quot;&gt;犹太教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%8F%8D%E7%8C%B6%E4%B8%BB%E7%BE%A9&quot;&gt;反犹太主义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%A4%A9%E4%B8%BB%E6%95%99&quot;&gt;天主教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%9D%B1%E6%AD%A3%E6%95%99&quot;&gt;东正教&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%96%B0%E6%95%99&quot;&gt;基督新教&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;TL:DR&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不要被博客长度迷惑，其实我什麼都不懂。&lt;/li&gt;
&lt;li&gt;如果你觉得没有一句人话，我也没办法，实在找不到说人话的资料。&lt;/li&gt;
&lt;li&gt;如果你觉得太长没兴趣读，恩，我也这么觉得，整理的几周我快闷死了。&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>随内容滚动隐藏的工具栏</title>
     <link href="http://beiyuu.com/blog/auto-edit-bar"/>
     <updated>2012-12-27T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/auto-edit-bar</id>
     <content type="html">&lt;p&gt;最先在&lt;a href=&quot;https://itunes.apple.com/us/app/google+/id447119634?mt=8&quot;&gt;Google+&lt;/a&gt;的APP上看到这种交互细节，而后在&lt;a href=&quot;http://www.meilishuo.com/welcome&quot;&gt;美丽说&lt;/a&gt;的新版上也看到了，上图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/other/auto-edit-bar.jpg&quot; alt=&quot;Auto Edit Bar&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中画蓝色线框的部分既是。打开APP，下面的工具栏部分是显示的，当手指滑动内容，如果是向下浏览更多内容，工具栏自动收起，如果向上回滚，工具栏又会显示。&lt;/p&gt;

&lt;p&gt;好处显而易见，当APP认为你在浏览，收起留出更多的屏幕空间，不遮挡、影响内容的显示，需要时再出现。&lt;/p&gt;

&lt;p&gt;起初看到这个交互，还有些不习惯，体会到他的优势之后，顿时又觉得不支持这样的APP实在太out。&lt;/p&gt;

&lt;p&gt;Google+和美丽说还有些不同的细节：
&lt;ul&gt;
    &lt;li&gt;Google+是在手指动作触发刚开始时就起效，而美丽说做在了手指滑动之后，因为有个缓冲时间，所以略感迟钝。&lt;/li&gt;
    &lt;li&gt;美丽说在工具栏收起之后，留有一个小按钮，其实当用户熟悉这个交互后，略显多余。&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Git时代的VIM不完全使用教程</title>
     <link href="http://beiyuu.com/blog/git-vim-tutorial"/>
     <updated>2012-11-27T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/git-vim-tutorial</id>
     <content type="html">&lt;p&gt;最近整理了VIM的配置，换上插件管理的神器-----&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;，由他引发的VIM生态环境的改善，堪称完美。遂打算写一份简单的教程，分享Git时代VIM新世界的美丽动人之处。&lt;strong&gt;对VIM有基础的同学，可直接跳至插件管理部分。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;VIM的模式&lt;/h2&gt;

&lt;p&gt;第一次使用VIM，会觉得无所适从，他并不像记事本，你敲什么键就显示什么，理解VIM的需要明白他的两种模式：
- 命令模式 (Command Mode)
- 编辑模式 (Insert Mode)&lt;/p&gt;

&lt;p&gt;命令模式下，可以做移动、编辑操作；编辑模式则用来输入。键入&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;o&lt;/code&gt;,&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;a&lt;/code&gt;等即可进入编辑模式，后面解释原因。&lt;/p&gt;

&lt;p&gt;模式的设计是VIM和其他编辑器最不同的地方，优势和劣势也全基于此而生。&lt;/p&gt;

&lt;h2&gt;基本操作&lt;/h2&gt;

&lt;p&gt;以下介绍的键盘操作，都是大小写敏感的，并且要在&lt;strong&gt;命令模式&lt;/strong&gt;下完成，需注意：&lt;/p&gt;

&lt;h3&gt;以字为单位的移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt; 向左移动一个字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt; 向下移动一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; 向上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; 向右&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这四个键在右手最容易碰到几个位置，最为常用。&lt;/p&gt;

&lt;h3&gt;以词为单位的移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 下一個word w(ord)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; 下一個word(跳过标点)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 前一個word b(ackward)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 前一个word(跳过标点)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt; 跳到当前word的尾端 e(nd)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;行移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 跳到当前行的开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 跳到当前行第一个非空字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 跳到行尾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;助记：0(第0个字符),&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;含义同正则表达式&lt;/p&gt;

&lt;h3&gt;段落移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{&lt;/code&gt; 上一段(以空白行分隔)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt; 下一段(以空白行分隔)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; 跳到当前对应的括号上(适用各种配对符号)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;跳跃移动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/xxxx&lt;/code&gt; 搜索xxxx，然后可以用&lt;code&gt;n&lt;/code&gt;下一个，&lt;code&gt;N&lt;/code&gt;上一个移动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 向前搜索光标当前所在的字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 向后搜索光标当前所在的字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fx&lt;/code&gt; 在当前行移动到光标之后第一个字符x的位置 f(ind)x&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gd&lt;/code&gt; 跳到光标所在位置词(word)的定义位置 g(o)d(efine)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt; 到文档顶部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 到文档底部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:x&lt;/code&gt; 跳到第x行(x是行号)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+d&lt;/code&gt; 向下翻页 d(down)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+u&lt;/code&gt; 向上翻页 u(p)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;基本编辑&lt;/h3&gt;

&lt;h4&gt;修改&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 在光标当前位置向前插入 i(nsert)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 在本行第一个字符前插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 在光标当前位置向后插入 a(fter)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 在本行末尾插入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 向下插入一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt; 向上插入一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt; 保存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt; 退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt; 保存并退出&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;删除&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 删除当前字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt; 删除当前行 d(elete)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw&lt;/code&gt; 删除当前光标下的词 d(elete)w(ord)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;复制粘贴&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yy&lt;/code&gt; 复制当前行 y(ank)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yw&lt;/code&gt; 复制当前光标下的词 y(ank)w(ord)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 粘贴 p(aste)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt; 粘贴在当前位置之前&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;进阶操作&lt;/h2&gt;

&lt;p&gt;限于篇幅，在这里我仅介绍下我非常常用的几个操作。&lt;/p&gt;

&lt;h3&gt;重复操作&lt;/h3&gt;

&lt;p&gt;因为VIM所有的操作都是原子化的，所以把这些操作程序化就非常简单了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;5w&lt;/code&gt; 相当于按五次&lt;code&gt;w&lt;/code&gt;键；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;6j&lt;/code&gt; 下移6行，相当于按六次j；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3J&lt;/code&gt; 大写J,本来是将下一行与当前行合并，加上数量，就是重复操作3次；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;6dw&lt;/code&gt;和&lt;code&gt;d6w&lt;/code&gt; 结果是一样，就是删除6个word；&lt;/li&gt;
&lt;li&gt;剩下的无数情况，自己类推吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;高效编辑&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;di&amp;quot;&lt;/code&gt; 光标在&amp;quot;&amp;quot;之间，则删除&amp;quot;&amp;quot;之间的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yi(&lt;/code&gt; 光标在()之间，则复制()之间的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vi[&lt;/code&gt; 光标在[]之间，则选中[]之间的内容&lt;/li&gt;
&lt;li&gt;以上三种可以自由组合搭配，效率奇高，i(nner)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dtx&lt;/code&gt; 删除字符直到遇见光标之后的第一个&lt;code&gt;x&lt;/code&gt;字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ytx&lt;/code&gt; 复制字符直到遇见光标之后的第一个&lt;code&gt;x&lt;/code&gt;字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;标记和宏(macro)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ma&lt;/code&gt; 将当前位置标记为a，26个字母均可做标记，&lt;code&gt;mb&lt;/code&gt;、&lt;code&gt;mc&lt;/code&gt;等等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;#39;a&lt;/code&gt; 跳转到a标记的位置；&lt;/li&gt;
&lt;li&gt;这是一组很好的文档内标记方法，在文档中跳跃编辑时很有用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qa&lt;/code&gt; 将之后的所有键盘操作录制下来，直到再次在命令模式按下&lt;code&gt;q&lt;/code&gt;，并存储在&lt;code&gt;a&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@a&lt;/code&gt; 执行刚刚记录在&lt;code&gt;a&lt;/code&gt;里面的键盘操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@&lt;/code&gt; 执行上一次的macro操作；&lt;/li&gt;
&lt;li&gt;宏操作是VIM最为神奇的操作之一，需要慢慢体会其强大之处；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;VIM的基本操作，可以挖掘的东西非常多，不仅仅需要记忆，更需要自己去探索总结，熟练之后，效率会大幅度提升。后面会给出一些参考链接。&lt;/p&gt;

&lt;h2&gt;插件管理&lt;/h2&gt;

&lt;h3&gt;Vundle&lt;/h3&gt;

&lt;p&gt;终于到这篇Blog我最想讨论的部分了。VIM的强大不仅仅体现在操作的高效率，更有强大而充沛的插件做支援，插件丰富了之后，就面临查找和管理的问题。&lt;/p&gt;

&lt;p&gt;在遇见&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;之前，我用&lt;a href=&quot;https://github.com/tpope/vim-pathogen&quot;&gt;Pathogen&lt;/a&gt;管理插件。Pathogen还算方便，只需要把相应插件，放在&lt;code&gt;bundle&lt;/code&gt;目录下即可，不需要再像以前那样逐个放置单独的文件到相应目录，大大节省了劳动力，管理起来也一目了然，觉得还不错，至少比vimball那种需要执行命令安装的方式好一些。&lt;/p&gt;

&lt;p&gt;我真希望我早些遇见Vundle。Vundle受到Pathogen和Vimball的启发，于是有了现在的模样。Vundle的逻辑是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;Vim Script&lt;/a&gt;选好你想要的插件；&lt;/li&gt;
&lt;li&gt;在VIM的配置文件中写一句 &lt;code&gt;Bundle plugin_name&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;执行一下Vundle的初始化命令，插件就装好了；&lt;/li&gt;
&lt;li&gt;升级和卸载也是同样的简单；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完美的世界！&lt;/p&gt;

&lt;h3&gt;Vundle的配置&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;的安装很简单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;git clone http://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后写配置文件&lt;code&gt;.vimrc&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;set nocompatible    &amp;quot; be iMproved
filetype off        &amp;quot; required!

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

&amp;quot; let Vundle manage Vundle
&amp;quot; required!
Bundle &amp;#39;gmarik/vundle&amp;#39;

&amp;quot; vim-scripts repos
Bundle &amp;#39;vim-plugin-foo&amp;#39;
Bundle &amp;#39;vim-plugin-bar&amp;#39;

filetype plugin indent on    &amp;quot; required!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;Bundle&lt;/code&gt;后面的内容，就是插件的名字，插件维护在&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;Vim-Script.org&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;然后，打开VIM之后，可以输入以下命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;quot;安装插件:
:BundleInstall

&amp;quot;更新插件:
:BundleInstall!

&amp;quot;卸载不在列表中的插件:
:BundleClean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在大部分的插件都已经从&lt;a href=&quot;http://www.vim.org/scripts/index.php&quot;&gt;Vim.org&lt;/a&gt;迁移到了&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;Vim-Script.org&lt;/a&gt;，而且很多作者也认领了自己的插件，直接在这个Github的项目下更新，一个比Vim.org更科学更有效的生态环境，就这样完美的形成了。&lt;/p&gt;

&lt;p&gt;在此非常严重的感谢vim-scripts.org的创建者&lt;a href=&quot;https://github.com/bronson&quot;&gt;Scott Bronson&lt;/a&gt;，和&lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;Vundle&lt;/a&gt;的作者&lt;a href=&quot;https://github.com/gmarik&quot;&gt;gmarik&lt;/a&gt;。他们的创新和分享精神，让这个世界又美好了一些。&lt;/p&gt;

&lt;p&gt;也感谢业界良心&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt;。Vim-Scripts.org整站就是用&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;建立维护的，对于个人来说，这是很好的选择，有兴趣的同学可以参看我之前的博客：&lt;a href=&quot;http://beiyuu.com/github-pages/&quot;&gt;使用Github Pages建独立博客&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;插件介绍&lt;/h2&gt;

&lt;p&gt;有了Vundle，再装插件就是件享受的事情了。我常用的插件有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#相较于Command-T等查找文件的插件，ctrlp.vim最大的好处在于没有依赖，干净利落
Bundle &amp;#39;ctrlp.vim&amp;#39;

#在输入()，&amp;quot;&amp;quot;等需要配对的符号时，自动帮你补全剩余半个
Bundle &amp;#39;AutoClose&amp;#39;

#神级插件，ZenCoding可以让你以一种神奇而无比爽快的感觉写HTML、CSS
Bundle &amp;#39;ZenCoding.vim&amp;#39;

#在()、&amp;quot;&amp;quot;、甚至HTML标签之间快速跳转；
Bundle &amp;#39;matchit.zip&amp;#39;

#显示行末的空格；
Bundle &amp;#39;ShowTrailingWhitespace&amp;#39;

#JS代码格式化插件；
Bundle &amp;#39;_jsbeautify&amp;#39;

#用全新的方式在文档中高效的移动光标，革命性的突破
Bundle &amp;#39;EasyMotion&amp;#39;

#自动识别文件编码；
Bundle &amp;#39;FencView.vim&amp;#39;

#必不可少，在VIM的编辑窗口树状显示文件目录
Bundle &amp;#39;The-NERD-tree&amp;#39;

#NERD出品的快速给代码加注释插件，选中，`ctrl+h`即可注释多种语言代码；
Bundle &amp;#39;The-NERD-Commenter&amp;#39;

#解放生产力的神器，简单配置，就可以按照自己的风格快速输入大段代码。
Bundle &amp;#39;UltiSnips&amp;#39;

#让代码更加易于纵向排版，以=或,符号对齐
Bundle &amp;#39;Tabular&amp;#39;

#迄今位置最好的自动VIM自动补全插件了吧
#Vundle的这个写法，是直接取该插件在Github上的repo
Bundle &amp;#39;Valloric/YouCompleteMe&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上插件可以在&lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;vim-script.org&lt;/a&gt;找到源码和文档，&lt;a href=&quot;http://mattn.github.com/zencoding-vim/&quot;&gt;ZenCoding&lt;/a&gt;和&lt;a href=&quot;http://net.tutsplus.com/tutorials/other/vim-essential-plugin-easymotion/&quot;&gt;EasyMotion&lt;/a&gt;演示点链接,你会心动的。&lt;/p&gt;

&lt;h2&gt;.vimrc配置&lt;/h2&gt;

&lt;p&gt;因为配置不断在更新，所以放上我的配置的链接：&lt;a href=&quot;https://github.com/beiyuu/vimfiles/blob/master/_vimrc&quot;&gt;.vimrc配置&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;更多&lt;/h2&gt;

&lt;p&gt;VIM在一开始会觉得非常不习惯，一定要坚持下去，收获的会更多，不仅仅是在装大侠方面的哦~&lt;/p&gt;

&lt;p&gt;关于VIM的使用，这篇博客仅仅介绍了很小的一部分，网络上还有大量朋友总结的心得，常学常有收获：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/10599776/&quot;&gt;Practical Vim&lt;/a&gt;，强烈推荐的一本系统介绍VIM的书籍&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/vim/&quot;&gt;Vim Cheat Sheet&lt;/a&gt;，有VIM的各种助记图，可以作为桌面&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.vimer.cn/&quot;&gt;Vimer的程序世界&lt;/a&gt;，不错的站，博主持续钻研VIM各种技巧&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hi.baidu.com/whqvzhjoixbbdwd/item/11315a5073667d0de6c4a5e9&quot;&gt;网友狂人收集的vim资料链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rayninfo.co.uk/vimtips.html&quot;&gt;Best of Vim Tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.limboy.com/2009/05/30/vim-setting/&quot;&gt;面向前端开发者和TextMate粉丝的vim配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scmbob.org/vim_fdm.html&quot;&gt;Vim代码折叠简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.longwin.com.tw/2009/03/choose-vim-color-scheme-2009/&quot;&gt;挑選 Vim 顏色(Color Scheme)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb&quot;&gt;vimium&lt;/a&gt;，用VIM的操作习惯来控制Chrome的插件&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>使用Backbone.js开发Chrome便签插件</title>
     <link href="http://beiyuu.com/blog/backbone-js-chrome-extension"/>
     <updated>2012-10-16T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/backbone-js-chrome-extension</id>
     <content type="html">&lt;h2&gt;开始之前&lt;/h2&gt;

&lt;p&gt;在Web Store上没找到满意的便签插件，就只好自己动手写了&lt;a href=&quot;https://chrome.google.com/webstore/detail/notty-notes/ggbmjahbkbhakkfgjiggdclpmmpmhajn?hl=zh-CN&quot; title=&quot;Notty Notes&quot;&gt;Notty Notes&lt;/a&gt;，你可以试试看，多多提建议哦~
&lt;a href=&quot;https://chrome.google.com/webstore/detail/notty-notes/ggbmjahbkbhakkfgjiggdclpmmpmhajn?hl=zh-CN&quot; title=&quot;Notty Notes&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/backbonechrome/notes-logo.jpg&quot; alt=&quot;Notty Notes&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://backbonejs.org&quot; title=&quot;Backbone.js&quot;&gt;Backbone&lt;/a&gt;的流行，与前端复杂度的提高息息相关，尤其越来越多的大型单页应用的上线，代码的组织方面就产生很多新的问题。所以MV*的概念又一次在前端应用开来，不管最后那个*被定义成为什么，M(odel)和V(iew)这两层的分离，对于代码的组织大有好处。Backbone就是很简洁恰当的解决了这个问题，并没有带来一点点多余之物，这也是他的动人之处。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.google.cn/intl/zh-CN/chrome/browser/&quot; title=&quot;Chrome Broswer&quot;&gt;Chrome&lt;/a&gt;的美丽与Backbone有相同之处。他的插件开发流程令人愉悦，&lt;a href=&quot;https://chrome.google.com/webstore/category/home&quot; title=&quot;Chrome Web Store&quot;&gt;Chrome Web Store&lt;/a&gt;上展现率和安装率也挺让人安慰，那丁点的热情也不会被打消掉。所以，综合种种，我又结合Backbone.js的使用，总结出来这片Blog。&lt;/p&gt;

&lt;h2&gt;Backbone.js简介&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Backbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是官方的介绍，Backbone.js给web应用开发约定了一种结构，包括用key-value绑定且可以自定义事件的Models，提供大量API方法的Models的集合Collections，以及用来响应事件的Views，并把这些很好的与你的RESTful的Json接口相结合，有效的组织复杂应用的代码。Backbone.js基于&lt;a href=&quot;http://jquery.com/&quot; title=&quot;jQuery&quot;&gt;jQuery&lt;/a&gt;和&lt;a href=&quot;http://underscorejs.org/&quot; title=&quot;UnderScore.js&quot;&gt;Underscore&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Backbone算轻量级的MVC框架，他的优雅之处在于，他为复杂的代码约定了一种优美的组织方式。使用Backbone可以脱离处理复杂DOM的苦海。你的数据就是&lt;code&gt;Models&lt;/code&gt;，&lt;code&gt;Collections&lt;/code&gt;是&lt;code&gt;Models&lt;/code&gt;的集合，&lt;code&gt;Models&lt;/code&gt;的每一个变化都会触发&lt;code&gt;change&lt;/code&gt;事件，&lt;code&gt;Views&lt;/code&gt;用来响应数据的变化。就我的使用效果来说，对于相同功能的应用，代码量减少至少30%以上，更别说在可维护性方面带来的提高了。&lt;/p&gt;

&lt;p&gt;相对于基本的HTML页面，Backbone.js的更适用于单页复杂应用(Single Page Application)。什么是单页复杂应用，比如Gmail、Google Reader、阿尔法城等，当然包括我将要讨论的便签插件。&lt;/p&gt;

&lt;h2&gt;Notes页面准备&lt;/h2&gt;

&lt;p&gt;便签是很直观、简单的东西，设计思路基本上模拟真实物品，所以也没多费神，实现的结果就是这样子的：
&lt;img src=&quot;/images/backbonechrome/notes-draft.jpg&quot; alt=&quot;Notes Draft&quot;&gt;&lt;/p&gt;

&lt;p&gt;为了一些简单的自定义功能，还有这样的设置页：
&lt;img src=&quot;/images/backbonechrome/notes-settings.jpg&quot; alt=&quot;Notes Settings&quot;&gt;&lt;/p&gt;

&lt;p&gt;总体来看，页面元素很简单，独立的三个模块：便签模板、关闭浮层、设置浮层。&lt;/p&gt;

&lt;p&gt;为了不让过多的代码占据篇幅，简写如下，后面会给出源码地址：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;body id=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;!--便签模板--&amp;gt;
    &amp;lt;div class=&amp;quot;note-tmpl&amp;quot; id=&amp;quot;note-template&amp;quot;&amp;gt;
        &amp;lt;!--Something Code...--&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;!--设置浮层--&amp;gt;
    &amp;lt;div class=&amp;quot;modal hide fade&amp;quot; id=&amp;quot;modal-settings&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-body&amp;quot;&amp;gt;
            &amp;lt;!--Something Code...--&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;modal-footer&amp;quot;&amp;gt;
            &amp;lt;!--Something Code...--&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;!--关闭浮层--&amp;gt;
    &amp;lt;div id=&amp;quot;tmpl-close&amp;quot; class=&amp;quot;hide&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;alert fade in tmpl-close-confirm&amp;quot;&amp;gt;
            &amp;lt;!--Something Code...--&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了快速搭建，使用了&lt;a href=&quot;http://twitter.github.com/bootstrap/&quot; title=&quot;Bootstrap&quot;&gt;Bootstrap&lt;/a&gt;，其中的modal就是Bootstrap的模态对话框，Bootstrap更多特性可以参考官方文档，这里就不展开了。&lt;/p&gt;

&lt;p&gt;样式我这样不懂审美的土鳖来说，是最困难的，只能根据直觉慢慢调整，还好CSS3方便了很多，不然最终肯定都是无聊的线框。不用兼容浏览器，那些漂亮的样式可以敞开了写，不过从设计角度来说，过于绚丽会导致操作效率降低，令用户产生厌烦，恰到好处是最好的，这方面我只到有直觉的水平，并无有价值的理论经验可分享。最终效果自己体会就好，关注如何实现，可以到源码中一看究竟。&lt;/p&gt;

&lt;p&gt;用到的插件除了&lt;a href=&quot;http://twitter.github.com/bootstrap/&quot; title=&quot;Bootstrap&quot;&gt;Bootstrap&lt;/a&gt;以外，还有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jqueryui.com/&quot; title=&quot;jQuery UI&quot;&gt;jQueryUI&lt;/a&gt;，包括拖拽和放大缩小插件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://daneden.me/animate/&quot; title=&quot;Animate.css&quot;&gt;Animate.css&lt;/a&gt;，很不错的CSS3动画插件，只包含css文件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jeromegn/Backbone.localStorage&quot; title=&quot;Backbone.localStorage.js&quot;&gt;Backbone.localStorage.js&lt;/a&gt;，Backbone本地存储的适配器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gbirke/Sanitize.js&quot; title=&quot;Sanitize.js&quot;&gt;Sanitize.js&lt;/a&gt;，清理过滤HTML节点。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://underscorejs.org/&quot; title=&quot;UnderScore.js&quot;&gt;UnderScore&lt;/a&gt;，Backbone依赖UnderScore.js。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;页面的部分不是这篇博客的重点，就像平常开发一样。在做这个完全我自己设计开发的东西的过程中，体会到想达到很优雅的用户体验，需要关注和解决的问题很多，是一个非常考验耐心的事情，不过最终完成时候的成就感自然也不同啦。&lt;/p&gt;

&lt;h2&gt;Backbone.js的Model&lt;/h2&gt;

&lt;p&gt;Model就是要操作对象的数据结构，存储需要用到的数据，基于这些数据，会有大量的交互、验证等等操作。&lt;/p&gt;

&lt;h3&gt;Model声明&lt;/h3&gt;

&lt;p&gt;根据要做的便签的需要，数据结构定义为如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var Note = Backbone.Model.extend({
    defaults:{
        position:{top:20,left:30}
        ,scale:{width:300,height:300}
        ,theme:&amp;#39;0&amp;#39;
        ,fonttheme:&amp;#39;1&amp;#39;
        ,customfont:&amp;#39;16&amp;#39;
        ,title:&amp;#39;Note&amp;#39;
        ,content:&amp;#39;&amp;#39;
        ,collapsed:&amp;#39;&amp;#39;
        ,locked:false
        ,contentHeight:248
        ,ref:{title:&amp;#39;&amp;#39;,href:&amp;#39;&amp;#39;}
    }

    ,initialize:function(){
        console.log(&amp;#39;Model initialized!&amp;#39;);
    }
    ,remove:function(){
        this.destroy();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，我们定义了Note的Model的默认值，还有initialize和remove方法，当new一个Note对象时候，initialize方法会执行，默认的值也会赋给new的对象。&lt;/p&gt;

&lt;h3&gt;Model值的set方法&lt;/h3&gt;

&lt;p&gt;也可以在new的时候修改覆盖默认值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var note1 = new Note({title:&amp;#39;New Note&amp;#39;,content:&amp;#39;This is the new note&amp;#39;});//覆盖默认的title和content

var note2 = new Note();
note2.set({title:&amp;#39;New Note 2&amp;#39;,content:&amp;#39;This is the new note 2&amp;#39;}); //设置Model的值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Model值的get方法&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var note3 = new Note();
note3.set({title:&amp;#39;New Note 3&amp;#39;,content:&amp;#39;This is the new note 3&amp;#39;}); //设置Model的值

var title = note3.get(&amp;#39;title&amp;#39;); // &amp;quot;New Note 3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;监听Model的change事件&lt;/h3&gt;

&lt;p&gt;要监听change事件，可以在initialize方法中做，也可以在实例化之后做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var note4 = new Note({title:&amp;#39;New Note 4&amp;#39;,content:&amp;#39;This is the new note 4&amp;#39;});
note4.bind(&amp;#39;change:title&amp;#39;,function(){
    //some code...
});
note4.bind(&amp;#39;change:theme&amp;#39;,function(){
    //some code...
});
note4.bind(&amp;#39;change:fonttheme&amp;#39;,function(){
    //some code...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;与服务端的交互&lt;/h3&gt;

&lt;p&gt;在这个应用中，无需与服务端交互，用了那个localStorage的补充插件之后，同样调用save()和destory()方法就好，该插件会自动完成相应的工作，真正与服务端的交互也很简单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var UserModel = Backbone.Model.extend({
    urlRoot: &amp;#39;/user&amp;#39;
    ,defaults: {
        name: &amp;#39;&amp;#39;
        ,email: &amp;#39;&amp;#39;
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中urlRoot用来定义服务端的RESTful的API接口。&lt;/p&gt;

&lt;p&gt;新建：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var UserModel = Backbone.Model.extend({
    urlRoot: &amp;#39;/user&amp;#39;
    ,defaults: {
        name: &amp;#39;&amp;#39;
        ,email: &amp;#39;&amp;#39;
    }
});
var user = new Usermodel();
// 注意这里没有id
var userDetails = {
    name: &amp;#39;notty&amp;#39;
    ,email: &amp;#39;notty@example.com&amp;#39;
};
//因为没有设置id，所以服务端接收到请求的时候，会自动新建，并添加id
user.save(userDetails, {
    success: function (user) {
        alert(user.toJSON());
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// 这里设置了id
var user = new Usermodel({id: 1});

// 下面这个方法会使用GET /user/1
// 服务端返回相应的数据
user.fetch({
    success: function (user) {
        alert(user.toJSON());
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// 我们修改id为1的用户数据
var user = new Usermodel({
    id: 1,
    name: &amp;#39;notes&amp;#39;,
    email: &amp;#39;notes@gmail.com&amp;#39;
});

// 因为有id，所以Backbone.js会触发 PUT /user/1，并发送相应的数据给服务端
user.save({name: &amp;#39;Davis&amp;#39;}, {
    success: function (model) {
        alert(user.toJSON());
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;// 这里设置了model的id
var user = new Usermodel({
    id: 1
    ,name: &amp;#39;Notty&amp;#39;
    ,email: &amp;#39;Notty@example.com&amp;#39;
});

// 因为有id，所以触发 DESTROY /user/1 
user.destroy({
    success: function () {
        alert(&amp;#39;Destroyed&amp;#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Model还支持validate方法，可以对数据进行校验，校验不通过，则不能执行后续操作，在声明Model时候，增加validate方法就好：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Person = Backbone.Model.extend({
    // 如果年龄小于0，就会报错
    validate: function( attributes ){
        if( attributes.age &amp;lt; 0 &amp;amp;&amp;amp; attributes.name != &amp;quot;Dr Manhatten&amp;quot; ){
            return &amp;quot;You can&amp;#39;t be negative years old&amp;quot;;
        }
    }
    ,initialize: function(){
        alert(&amp;quot;Welcome to this world&amp;quot;);
        this.bind(&amp;quot;error&amp;quot;, function(model, error){
            alert( error );
        });
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Backbone.js的Collection&lt;/h2&gt;

&lt;p&gt;Collection的概念很好理解，他就是Model的一个简单集合，举几个例子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Model是歌，Collection是专辑&lt;/li&gt;
&lt;li&gt;Model是动物，Collection是动物园&lt;/li&gt;
&lt;li&gt;Model是一个便签，Collection是所有便签（囧）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建一个Collection，Model还是之前的便签的Model：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var NoteCollection = Backbone.Collection.extend({
    model:Note
    ,localStorage:new Backbone.LocalStorage(&amp;#39;notty-note&amp;#39;)
});

var note1 = new Note({title:&amp;#39;New Note&amp;#39;,content:&amp;#39;This is the new note&amp;#39;});
var note2 = new Note({title:&amp;#39;New Note 2&amp;#39;,content:&amp;#39;This is the new note 2&amp;#39;});
var note3 = new Note({title:&amp;#39;New Note 3&amp;#39;,content:&amp;#39;This is the new note 3&amp;#39;});

var Notes = new NoteCollection([note1,note2,note3]);
console.log(Notes.models) //[note1,note2,note3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，我们的便签插件不需要与服务端交互，但是需要本地存储，所以使用localStorage。&lt;/p&gt;

&lt;h2&gt;Backbone.js的View&lt;/h2&gt;

&lt;p&gt;好了，重头来了，View的声明和其他的基本上一样，一些参数查文档就很容易明白：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var NoteView = Backbone.View.extend({
    tagName:&amp;#39;div&amp;#39;
    ,className:&amp;#39;note&amp;#39;
    ,template:function(tmpl,obj){
    }
    ,initialize:function(){
    }
    ,render:function(){
        return this;
    }
    ,events:{
        &amp;#39;mousedown&amp;#39;:&amp;#39;clickNote&amp;#39;
        ,&amp;#39;dblclick .note-nav&amp;#39;:&amp;#39;foldContent&amp;#39;
        ,&amp;#39;click .note-nav-close&amp;#39;:&amp;#39;deleteNote&amp;#39;
        ,&amp;#39;click .note-nav-lock&amp;#39;:&amp;#39;lockNote&amp;#39;
        ,&amp;#39;click .note-nav-title&amp;#39;:&amp;#39;settings&amp;#39;
        ,&amp;#39;keyup .note-content&amp;#39;:&amp;#39;contentChange&amp;#39;
        ,&amp;#39;blur .note-content&amp;#39;:&amp;#39;contentChange&amp;#39;
    }
    ,clickNote:function(e){
    }
    ,deleteNote:function(e){
    }
    ,lockNote:function(e){
    }
    ,settings:function(){
    }
    ,contentChange:function(e){
    }
    ,changeScaleAndContentHeight:function(view){
    }
    ,bringNoteToContainer:function(view){
    }
    ,bringNoteToFront:function($ele){
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个应用中，分离了每个便签的View和整个app的View，这样做的好处是逻辑、代码更清晰。&lt;/p&gt;

&lt;h3&gt;el属性&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;this.el&lt;/code&gt;是这个View的DOM引用，使用它可以方便的做很多操作DOM的事情。注意到在这个View的声明里面，定义了template函数，不适用Underscore自带的template的函数的原因是Chrome Manifest V2的版本里面不允许出现&lt;code&gt;new Function&lt;/code&gt;，导致很多模板库不能使用，只好自己重写一个简单的。&lt;code&gt;template&lt;/code&gt;在这个场景还是能非常方便的解决一些问题的。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;this.el&lt;/code&gt;我们如何给View填充数据呢，很简单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var $ele = $(this.el);
$ele.html(
    this.template(&amp;#39;#note-template&amp;#39;,model.toJSON())
).draggable({
    handle:&amp;#39;.note-nav&amp;#39;
    ,stack:&amp;#39;.note&amp;#39;
    ,stop:function(){
        var $el = $(this);
        that.bringNoteToContainer(that);
    }
}).css({
    position:&amp;#39;absolute&amp;#39;
    ,top:model.get(&amp;#39;position&amp;#39;).top
    ,left:model.get(&amp;#39;position&amp;#39;).left
    ,width:model.get(&amp;#39;scale&amp;#39;).width
    ,height:model.get(&amp;#39;scale&amp;#39;).height
}).resizable({
    minWidth:200
    ,minHeight:200
    ,handles:&amp;#39;e,w,s,se&amp;#39;
    ,alsoResize:$ele.find(&amp;#39;.note-content&amp;#39;)
    ,stop:function(){that.changeScaleAndContentHeight(that)}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;initialize&lt;/code&gt;方法中，可以初始化这些事情，需要更多的初始化工作，继续写写下去就好。&lt;/p&gt;

&lt;h3&gt;事件的监听&lt;/h3&gt;

&lt;p&gt;你肯定注意到了声明View代码中的下面这些：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;,events:{
    &amp;#39;mousedown&amp;#39;:&amp;#39;clickNote&amp;#39;
    ,&amp;#39;dblclick .note-nav&amp;#39;:&amp;#39;foldContent&amp;#39;
    ,&amp;#39;click .note-nav-close&amp;#39;:&amp;#39;deleteNote&amp;#39;
    ,&amp;#39;click .note-nav-lock&amp;#39;:&amp;#39;lockNote&amp;#39;
    ,&amp;#39;click .note-nav-title&amp;#39;:&amp;#39;settings&amp;#39;
    ,&amp;#39;keyup .note-content&amp;#39;:&amp;#39;contentChange&amp;#39;
    ,&amp;#39;blur .note-content&amp;#39;:&amp;#39;contentChange&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些用来给View绑定事件，就和平常使用jQuery一样的用法，相信你一看就明白。&lt;/p&gt;

&lt;h3&gt;appView&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;appView&lt;/code&gt;并不是Backbone的内容，而是在这个应用中，我们用来粘合所有元素的一个容器，为了将整个流程串联起来，有一个总体的概念，我会详细解释这部分的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;var appView = Backbone.View.extend({
    //指定appView的el，也是整个应用的总容器
    el:$(&amp;#39;#container&amp;#39;)

    //同样的initialize方法
    ,initialize:function(){

        //给数据绑定相应的事件
        this.collection.bind(&amp;#39;add&amp;#39;,this.addOne,this);
        this.collection.bind(&amp;#39;reset&amp;#39;,this.addAll,this);

        //这里的Notes就是便签Model的Collection
        //在初始化的时候，fetch方法从localStorage中取出所有数据
        Notes.fetch();
    }
    ,render:function(){
        return this;
    }

    //初始化一个便签note
    ,initOne:function(note){
        //这里的NoteView就是每个便签的View
        //NoteView使用数据Model就是note
        var view = new NoteView({model:note});
        var ele = view.render().el

        $(&amp;#39;#container&amp;#39;).append(ele)
        //细节处理
        view.bringNoteToContainer(view)
        return ele;
    }

    //当用户自主添加的时候，增加动画效果
    ,addOne:function(note){
        //前面的初始化还是一样
        var ele = this.initOne(note);

        //这里是Animate.css的动画
        $(ele).addClass(&amp;#39;animated bounceIn&amp;#39;);

        //洁癖，细节处理
        setTimeout(function(){
            $(ele).removeClass(&amp;#39;animated bounceIn&amp;#39;);
        },600);
    }

    //fetch之后会触发reset事件，我们绑定了这个方法
    ,addAll:function(){
        var that = this;
        var length = Notes.models.length;
        $.each(Notes.models,function(index,item){
            //一个个的初始化
            that.initOne(item)
        });
    }
});

//这里是真正的启动的代码
//指定了数据Collection
var app = new appView({collection:Notes});

//用户添加的时候事件处理
$(document).bind(&amp;#39;dblclick&amp;#39;,function(e){
    e.preventDefault();
    if(e.target==$(&amp;#39;html&amp;#39;)[0]){
        Notes.create({position:{top:e.pageY,left:e.pageX}});
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释很详细，也不用再赘述了。&lt;/p&gt;

&lt;h2&gt;Backbone.js更多资源&lt;/h2&gt;

&lt;p&gt;基本上到这里，使用Backbone.js整体的框架已经搭建好了，剩下的就是填充血肉了，这里面充满了细节，写的过程中慢慢体会、完善。再提供几个比较好的资源，以及这个插件的源码地址：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/beiyuu/Notty-Notes&quot;&gt;Notty Notes源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://documentcloud.github.com/backbone/&quot; title=&quot;Backbone Official&quot;&gt;Babkbone 官方站点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://backbonetutorials.com/&quot; title=&quot;Backbone Tutorials&quot;&gt;Backbone Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://documentcloud.github.com/backbone/examples/todos/index.html&quot; title=&quot;Backbone Todo&quot;&gt;简单的Todo实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.the5fire.net/backbone-tutorials-catalogue.html&quot; title=&quot;Backbone.js入门学习笔记目录&quot;&gt;Backbone 学习笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nuysoft/archive/2012/03/19/2404274.html&quot; title=&quot;Backbone 架构分析&quot;&gt;Backbone 架构分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/soasme/article/details/6581029&quot; title=&quot;Backbone HelloWorld&quot;&gt;Backbone HelloWorld（中文）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://weakfi.iteye.com/blog/1391990&quot; title=&quot;Backbone初探&quot;&gt;Backbone 初探&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://floatleft.com/notebook/backbone-has-made-me-a-better-programmer&quot; title=&quot;Backbone has made me a better programmer&quot;&gt;Backbone has made me a better programmer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Chrome插件&lt;/h2&gt;

&lt;p&gt;Chrome插件开发的流程很舒适、自然。为了先配好环境，就先大致的介绍一下插件开发的相关事宜。如果比较熟悉，可忽略跳过。更详细全面的说明参考&lt;a href=&quot;http://developer.chrome.com/extensions/getstarted.html&quot; title=&quot;Chrome Extension Get Started&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;manifest.json&lt;/h3&gt;

&lt;p&gt;每一个插件的&lt;code&gt;manifest.json&lt;/code&gt;文件必不可少，看看&lt;a href=&quot;https://chrome.google.com/webstore/detail/notty-notes/ggbmjahbkbhakkfgjiggdclpmmpmhajn?hl=zh-CN&quot; title=&quot;Notty Notes&quot;&gt;Notty Notes&lt;/a&gt;，也就是我们要写的插件的&lt;code&gt;manifest.json&lt;/code&gt;的内容吧：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;Notty Notes&amp;quot;
    ,&amp;quot;version&amp;quot;:&amp;quot;1.3&amp;quot;
    ,&amp;quot;manifest_version&amp;quot;:2
    ,&amp;quot;description&amp;quot;:&amp;quot;One of The Best Sticky Notes For Your Broswer&amp;quot;

    ,&amp;quot;app&amp;quot;: {
        &amp;quot;launch&amp;quot;: {
            &amp;quot;local_path&amp;quot;: &amp;quot;main.html&amp;quot;
        }
    }
    ,&amp;quot;icons&amp;quot;:{
        &amp;quot;16&amp;quot;:&amp;quot;assets/32.png&amp;quot;
        ,&amp;quot;32&amp;quot;:&amp;quot;assets/32.png&amp;quot;
    }

   ,&amp;quot;permissions&amp;quot;: [
       &amp;quot;unlimitedStorage&amp;quot;
   ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顾名思义的就不多讲了，现在较新版本的Chrome，会对那些没有使用manifest_version为2的插件提示，升级为2之后，Chrome对插件的权限控制会更多，之前用到一些比较方便的写法都会有问题，比如内联的JS，new一个Function等等，&lt;a href=&quot;http://www.qianduan.net/chrome-extension-upgrade-to-the-manifest-version-2-2.html&quot; title=&quot;Chrome extension 升级到 manifest version 2 的问题&quot;&gt;Chrome extension 升级到 manifest version 2 的问题&lt;/a&gt;里说明了一些问题，可以了解一下。&lt;/p&gt;

&lt;p&gt;根据插件的性质不同，&lt;code&gt;app&lt;/code&gt;部分会有不同，我们要开发的&lt;a href=&quot;https://chrome.google.com/webstore/detail/notty-notes/ggbmjahbkbhakkfgjiggdclpmmpmhajn?hl=zh-CN&quot; title=&quot;Notty Notes&quot;&gt;便签插件&lt;/a&gt;是一个独立页面的应用，所以按照上述的方法写，如果是那种只打开一个在线页面的链接型插件，只要改成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;,&amp;quot;app&amp;quot;: {
    &amp;quot;launch&amp;quot;: {
        &amp;quot;web_url&amp;quot;: &amp;quot;http://overapi.com/?chrome&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是浏览器增强型的，可以写成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;,&amp;quot;browser_action&amp;quot;: {
    &amp;quot;default_icon&amp;quot;:&amp;quot;assets/24.png&amp;quot;
    ,&amp;quot;default_title&amp;quot;:&amp;quot;Notty Notes&amp;quot;
    ,&amp;quot;default_popup&amp;quot;:&amp;quot;popup.html&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无需&lt;code&gt;app&lt;/code&gt;字段。按照你的需求，更多的可以参考&lt;a href=&quot;http://developer.chrome.com/extensions/manifest.html&quot; title=&quot;Manifest Files&quot;&gt;Manifest Files&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;permissions&lt;/code&gt;项是向Chrome请求需要的权限，在用户安装插件额时候，会有提示，可声明的权限可以参考&lt;a href=&quot;http://developer.chrome.com/extensions/manifest.html#permissions&quot; title=&quot;Manifest Permissions&quot;&gt;Permissions&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;开发调试&lt;/h3&gt;

&lt;p&gt;关于文件的组织，除了&lt;code&gt;manifest.json&lt;/code&gt;文件需要放在根目录之外，其他文件放在&lt;code&gt;manifest&lt;/code&gt;中指定的位置即可，不得不说，很愉悦。&lt;/p&gt;

&lt;p&gt;开发调试过程简单方便，在&lt;code&gt;扩展程序&lt;/code&gt;的管理页面，选择&lt;code&gt;载入正在开发的扩展程序&lt;/code&gt;，加载正在开发的文件目录就好，单页的应用，可直接在应用当页使用开发工具调试，&lt;code&gt;background&lt;/code&gt;类型的也可以方便的在&lt;code&gt;扩展程序&lt;/code&gt;页面看到打开调试工具的按钮。&lt;/p&gt;

&lt;p&gt;做完准备工作，余下的开发过程就同平常一样，修改代码，刷新，看效果，调BUG，毫无不适。&lt;/p&gt;

&lt;h2&gt;Chrome Web Store&lt;/h2&gt;

&lt;h3&gt;账号注册&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/category/home&quot; title=&quot;Chrome Web Store&quot;&gt;Chrome Web Store&lt;/a&gt;在早起测试阶段，可以免费注册使用，现在注册一个可发布应用的账号需要支付5美元的费用，而且得是信用卡，之前一直没办信用卡，所以写了的插件只能自己打包发布管理，异常的纷杂，办信用卡之后，第一件事就是注册Chrome Web Store。&lt;/p&gt;

&lt;p&gt;需要注意的一点是，填写地址部分，没有中国大陆的选项，不知道Google会不会检查信用卡发卡地和地址是否匹配，我选择了香港，瞎填了地址，也通过了，仅供参考。&lt;/p&gt;

&lt;h3&gt;发布、推广&lt;/h3&gt;

&lt;p&gt;Chrome Store上插件的发布很简单，把自己的插件按要求打包好，上传即可，介绍写的简洁动人一些，准备几个漂亮的图标，再做几张符合尺寸要求的宣传图，发布之后，很快就能生效在相关的分类里面看到。吐槽一下，我的宣传图上传好几天了，也没见通过审核的迹象，效率啊XD。&lt;/p&gt;

&lt;p&gt;最后再广告一下我的&lt;a href=&quot;https://chrome.google.com/webstore/detail/notty-notes/ggbmjahbkbhakkfgjiggdclpmmpmhajn?hl=zh-CN&quot; title=&quot;Notty Notes&quot;&gt;便签插件&lt;/a&gt;吧，感谢&lt;a href=&quot;http://www.douban.com/people/JGuo/&quot;&gt;靖哥哥&lt;/a&gt;帮我做宣传图：
&lt;a href=&quot;https://chrome.google.com/webstore/detail/notty-notes/ggbmjahbkbhakkfgjiggdclpmmpmhajn?hl=zh-CN&quot; title=&quot;Notty Notes&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/backbonechrome/notes-logo.jpg&quot; alt=&quot;Notty Notes&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>OverAPI</title>
     <link href="http://beiyuu.com/blog/overapi-cheatsheet"/>
     <updated>2012-09-22T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/overapi-cheatsheet</id>
     <content type="html">&lt;p&gt;&lt;a href=&quot;http://overapi.com&quot; title=&quot;OverAPI - Collecting all the cheat sheets&quot;&gt;OverAPI&lt;/a&gt;是一个从我自己的需求出发，搭建起来的项目。项目结构很简单，将常用语言的API很扁平的展现出来，方便翻阅和查找。&lt;/p&gt;

&lt;p&gt;Chrome插件下载：&lt;a href=&quot;https://chrome.google.com/webstore/detail/oedodeocfdeegliepeeoieemhdgoijod?hl=zh-CN&quot; title=&quot;All Cheat Sheets&quot;&gt;All Cheat Sheets&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://overapi.com&quot; title=&quot;OverAPI - Collecting all the cheat sheets&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/overapi/overapi.jpg&quot; alt=&quot;OverAPI&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;生活在继续，遇到的人和事越来越繁杂，于是，满目的秋意、愉悦的欢叫，都像微风一样，带来的是美妙的简单。&lt;/p&gt;

&lt;p&gt;我们总想拥有一切，可一切到底有多少，就像诺兰的处女作&lt;a href=&quot;http://movie.douban.com/subject/1397546/&quot; title=&quot;Following&quot;&gt;Following&lt;/a&gt;中表现的一样，一些物品只有在失去时才知道他存在过。&lt;/p&gt;

&lt;p&gt;人生有目标才能前进，无论这个目标能否实现，OverAPI的目标是拥有一切，如果你有兴趣一起实现，可以联系我。&lt;/p&gt;

&lt;p&gt;现在已经有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/python/&quot;&gt;Python Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/jquery/&quot;&gt;jQuery Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/nodejs/&quot;&gt;NodeJS Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/php/&quot;&gt;PHP Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/ruby/&quot;&gt;Ruby Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/javascript/&quot;&gt;Javascript Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/actionscript/&quot;&gt;ActionScript Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/css/&quot;&gt;CSS Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/git/&quot;&gt;Git Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/svn/&quot;&gt;SVN Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/mysql/&quot;&gt;MySQL Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/regex/&quot;&gt;Regex Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/linux/&quot;&gt;Linux Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/html/&quot;&gt;HTML Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/html-dom/&quot;&gt;HTML-DOM Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://overapi.com/mod_rewrite/&quot;&gt;mod_rewrite Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
 
</feed>
